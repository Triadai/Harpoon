pointer analysis
  will let us: determine hashcode/lock opt statically.
  will let us: improve optimization of array allocations
    99.9% compress, 44.7% jess, 45.7% javac, 79.1% mpegaud, 45.6% jack
    (break down by type)
  will let us: improve hashcode->enumeratoor (26.2% jack) halve size
  need to: rework transformations per alloc site?  fields may be
    constant/etc *per-alloc*, so transformations may only be valid
    at a single alloc site.
  also: can only do static spec on *final*(esque) fields; fields may
    now be final *at a particular allocation site*.

timing numbers
  claz compression:  not hard.  just add code to create table, use
   table.  easiest *not* to layout properly.  strategy: table or
   computed index (very hard packing problem if computed index)
  hash/lock compression: done in the static case.  eliminating this
   field should have no run-time costs (note that this is w/ existing
   layout).  dynamic case: need to write code, integrate it w/
   gc?  probably just use a hashtable of inflated objects.  very
   messy.
  field compression (bitwidth): done (but see 'bit/byte packing')
  static specialization: done.
  field externalization: done for the 'two word key'.  should have
   comparable timing.  'one word key' requires a field-numbering
   scheme; i think that's really it.  maybe some tombstone issues
   to think through?

actual layout.
 probably no big deal to allow 'java' packing of objects into
  free space next to claz pointer.
 hash/lock compression (elimination): requires making the hashcode
  a first-class field of java.lang.Object?  optimization is tricky
  here, if we want subclassing still to work right. make it a negative
  field?  probably requires stealing one bit from hash and claz to
  indicate which is the valid claz pointer.  will break karen's gc.
  (this means that you can decide to put the hashcode in at allocation
  time (and thus per-alloc site) and not per class or have subclass
  issues)
field compression.  done (but see 'bit/byte packing').  may have
  to break abstraction a bit to allow packing into claz?

bit/byte field packing.
 byte packing: need to refine field packing algorithm.  need to
  rewrite field accessor code to emit appropriate unaligned
  reads/writes.  maybe represent these in tree form?
  (also must export this to JNI so that JNI can properly access
   unaligned fields)
 bit packing: need to extend all field access/packing code to
  support bit-level alignment.  also JNI.  Same 'unaligned access'
  considerations as above, same 'new field packing algorithm' constraint.

benchmarks.
 java generics benchmark may show promise
 volano
 connect-4 (flourstone)
 javacup/javalex
 java makefile tool?

improved static specialization:
  will improve numbers for jess.Value by a *lot*. (may be done w/ or
  w/o p.a.) 23.2% total alloc

contained classes?  alloc-once anal.  associate elements info w/
  container's site, not array alloc site.  (now we can say, "only
  integers go into the elementData alloc'd at the Vector alloc site)
  containerizing.
