% -*-latex-*- This is a LaTeX document.
% $Id: transact.tex,v 1.15 2000-09-29 17:06:19 cananian Exp $
\documentclass[11pt,notitlepage]{article}
\usepackage[section,plain]{algorithm} % algorithm environment
\usepackage{alltt} % alltt environment
\usepackage{amstext} % the \text command for math mode
\usepackage{comdef} % common definitions
\usepackage{pdffonts} % PDF-friendly fonts
\author{C.~Scott~Ananian}
\title{Software Atomic Transactions in FLEX}
\date{\today \\ $ $Revision: 1.15 $ $}

% this is handy when talking about structure member references.
\newcommand{\ptr}{\code{->}}
% how big should code listings be?
\newcommand{\codesize}{\scriptsize}

\begin{document}
\bibliographystyle{abbrv}
\maketitle
\section{Data Structures}

Transaction support uses the same ``inflated object'' extension
mechanism which is used for thread synchronization, clustered heaps,
JNI data, and finalization for certain garbage collectors.
The basic object data structure, as shown in figure \ref{fig:oobj}, is
unchanged, although fields containing the specified
\texttt{FLAG\_VALUE} have different semantics.  The flag value is used
to indicate that the field value is ``not here''; that is, the code
must consult the transaction information to find the field's current
value.  This happens very rarely even when no transaction is
associated with the object; Shasta \cite{scales96:shasta} has shown that the
overhead entailed by such ``false'' transactions is expected to be
extremely low.

The ``inflated object'' data structure, shown in figure
\ref{fig:infl}, has a simple ``object versions'' linked list associated with
it.  Each entry conceptually stores information about a different,
possibly-uncommitted, version of the object.  One of these versions is
guaranteed to be ``most recent committed'', and it is guaranteed that
the ``most recent committed'' version will be the first committed
version in the list.

Note that the ``object version'' structure, shown in figure
\ref{fig:version}, is the same size as the object structure shown in
figure \ref{fig:oobj}, so that the same field offsets can be used.
In addition, the \texttt{vinfo} structure contains a ``next'' field
(as it is a singly linked list) and a pointer to a commit record which
identifies the transaction which this version is part of.  This allows
client code to determine which version it should address.

The commit record structure is shown in figure \ref{fig:commitrec}.
The pointer to the commit record also serves as a transaction
identifier.  Transactions can be nested, therefore every commit record
may contain a pointer to a ``parent'' transaction which it is
dependent upon.  The commit record also contains a three-value
``status'' field which indicates whether the transaction it represents
has been committed or aborted yet.

We can also chain commit records together using the ``waiting'' field
of the \texttt{commitrec} structure to more efficiently restart
transactions which aborted because of reservations held by this
one.  Experimentation will determine whether this is worthwhile or
whether a simple exponential backoff scheme will work better.
If this field is used, it is expected to link multiple ``aborted''
commit records to a single ``waiting'' record at the head.  When the
record at the head is either committed or aborted, the other
transactions should be restarted.

In practice, this will probably work better if there is a condition
value/mutex pair associated with every commit record which
transactions would signal when aborting or commiting --- but this
seems to entail too much overhead.  We don't want to have to
\texttt{pthread\_mutex\_lock} and \texttt{pthread\_cond\_signal} at every
transaction commit/abort, do we?

\begin{figure}
\begin{alltt}\codesize
/* the oobj structure tells you what's inside the object layout. */
struct oobj \{
  struct claz *claz;
  /* if low bit is one, then this is a fair-dinkum hashcode. else, it's a
   * pointer to a struct inflated_oobj. this pointer needs to be freed
   * when the object is garbage collected, which is done w/ a finalizer. */
  union \{ ptroff_t hashcode; struct inflated_oobj *inflated; \} hashunion;
\textbf{#ifdef WITH_TRANSACTIONS
#define FLAG_VALUE 0xCACACACA
  /* consult transaction to determine value of any field with FLAG_VALUE */
#endif}
  /* fields below this point */
  char field_start[0];
\};
\end{alltt}
\caption{The object structure in the FLEX runtime.}
\label{fig:oobj}
\end{figure}
\begin{figure}
\begin{alltt}\codesize
/* the inflated_oobj structure has various bits of information that we
 * want to associate with *some* (not all) objects. */
struct inflated_oobj \{
  ptroff_t hashcode; /* the real hashcode, since we've booted it */
  void *jni_data; /* information associated with this object by the JNI */
  void (*jni_cleanup_func)(void *jni_data);
\textbf{  int use_count; /* determines when we can deflate the object */
  /* TRANSACTION SUPPORT */
#if WITH_TRANSACTIONS
  struct vinfo *first_version; /* linked list of object versions */
#endif}
  /* locking information */
#if WITH_HEAVY_THREADS || WITH_PTH_THREADS
  pthread_t tid; /* can be zero, if no one has this lock */
  jint nesting_depth; /* recursive lock nesting depth */
  pthread_mutex_t mutex; /* simple (not recursive) lock */
  pthread_cond_t  cond; /* condition variable */
  pthread_rwlock_t jni_data_lock; /*read/write lock for jni_data field, above*/
#endif
#ifdef WITH_CLUSTERED_HEAPS
  struct clustered_heap * heap;
  void (*heap_release)(struct clustered_heap *);
#endif
#ifdef BDW_CONSERVATIVE_GC
  /* for cleanup via finalization */
  GC_finalization_proc old_finalizer;
  GC_PTR old_client_data;
#endif
\};
\end{alltt}
\caption{The ``inflated object'' structure in the FLEX runtime.
         Fields specific to transaction support are in boldface.}
\label{fig:infl}
\end{figure}

\begin{figure}
\begin{alltt}\codesize
#if WITH_TRANSACTIONS
/* The vinfo structure provides values for a given version of the object.
/* Note that it is identical in size to the oobj struct, so the same 
 * offsets can be used. */
struct vinfo \{
  struct commitrec *transid; /* transaction id */ 
  struct vinfo *next; /* next version. */
  /* fields below this point */
  char field_start[0];
\};
#endif
\end{alltt}
\caption{The ``version'' structure in the FLEX runtime.}
\label{fig:version}
\end{figure}

\begin{figure}
\begin{alltt}\codesize
#if WITH_TRANSACTIONS
/* The commit record for a (possibly nested) transaction */
struct commitrec \{
  /* The transaction that this depends upon, if any. */
  struct commitrec *parent;
  /* The 'state' should be initialized to W and write-once to C or A. */
  enum \{ WAITING=0, COMMITTED, ABORTED \} state;
  /* optional! (not sure we need/can use this at all) */
  /* this is a list of transactions which aborted waiting for this one. */
  /* martin sez we should use exponential back-off instead. */
  struct commitrec *waiting;
\};
#endif
\end{alltt}
\caption{Commit record structure.}
\label{fig:commitrec}
\end{figure}

\section{Algorithms}

Blah blah blah

\begin{figure}
$\text{Read}(\code{struct oobj *} o, \code{int } n)$ =
\begin{myalgorithmic}
\STATE $x \gets o\ptr \code{field}[n]$
\IF{$x = \code{FLAG\_VALUE}$}

\STATE $v \gets o \ptr \code{hashunion.inflated} \ptr \code{first\_version}$
\STATE $u \gets 0$ \COMMENT{count uncommitted transactions}
\LOOP
  \ASSERT $v \neq \code{null}$
  \MATCHING{$\text{StateP}(v \ptr \code{transid})$}
   \CASE{\code{COMMITTED}}
    \ASSERT \small$\forall n,\: o \ptr \code{field}[n]=\code{FLAG\_VALUE}
             \Rightarrow  v \ptr \code{field}[n] \text{ is valid }$
    \STATE \COMMENT{this store should be atomic (but no one will read it)}
    \STATE $v\ptr\code{next} \gets \code{null}$
           \COMMENT{allow gc of other transactions}
    \STATE \COMMENT{XXX: should check v\ptr\code{next}\ptr\code{transid}
                    for identical transid, in which case we'd need to prune.}
    \BREAK \textbf{loop}
   \ENDCASE
   \CASE{\code{ABORTED}}
    \STATE \COMMENT{XXX: potential race here --- v could be already removed}
    \STATE remove $v$ from version list atomically
    \STATE $v \gets v\text{'s replacement}$
   \ENDCASE
   \CASEDEFAULT
    \STATE $u \gets u + 1$
    \STATE $v \gets v \ptr \code{next}$
   \ENDCASE
  \ENDMATCHING
\ENDLOOP*
\STATE $x \gets v \ptr \code{field}[n]$
\IF{$u=0 \wedge x \neq \code{FLAG\_VALUE}$}
  \STATE \COMMENT{XXX: race here}
  \STATE $o \ptr \code{field}[n] \gets x$ \COMMENT{store must be atomic}
  \STATE $\code{dec\_use}(o)$
         \COMMENT{will deflate when all fields are copied back}
\ENDIF
\ENDIF
\RETURN $x$
\end{myalgorithmic}
\caption{Algorithm for non-transactional read of a field.}
\label{fig:readnotrans}
\end{figure}

\begin{figure}
$\text{Write}(\code{struct oobj *} o, \code{int } n,
              \code{<ty> } x)$ =
\begin{myalgorithmic}
\IF{$o\ptr\code{field}[n] = \code{FLAG\_VALUE}$}
  \STATE $v \gets o \ptr \code{hashunion.inflated} \ptr \code{first\_version}$
  \WHILE{$\text{AbortTransaction}(v\ptr\code{transid}) \neq \code{COMMITTED}$}
    \STATE \COMMENT{prune list for the sake of writes w/o intervening reads}
    \STATE \COMMENT{XXX: potential race here --- v could be already removed}
    \STATE remove $v$ from version list atomically
    \STATE $v \gets v\text{'s replacement}$
  \ENDWHILE
  \STATE $v\ptr\code{next} \gets \code{null}$ \COMMENT{atomic}
\ELSIF{$x = \code{FLAG\_VALUE}$}
  \STATE \COMMENT{XXX: define CreateNewVersion (watch those races)}
  \STATE $v = \text{CreateNewVersion}(o, o, o\ptr\code{claz}\ptr\code{size})$
\ELSE
  \STATE $v = o$
\ENDIF
\STATE $v\ptr\code{field}[n] \gets x$
\end{myalgorithmic}
\caption{Algorithm for non-transactional write of a field.}
\label{fig:writenotrans}
\end{figure}

\begin{figure}
$\text{ReadTrans}(\code{struct commitrec *}c, 
                  \code{struct oobj *} o, \code{int } n)=$
\begin{myalgorithmic}
\STATE $v \gets \text{appropriate version, creating it if necessary}$
  \COMMENT{doesn't abort non-appropriate versions}
\RETURN $v\ptr\code{field}[n]$
\end{myalgorithmic}
\caption{Algorithm for transactional read of a field.}
\label{fig:readtrans}
\end{figure}

\begin{figure}
$\text{WriteTrans}(\code{struct commitrec *}c, 
                   \code{struct oobj *} o, \code{int } n,
                   \code{<ty> } x)=$
\begin{myalgorithmic}
\STATE $v \gets \text{appropriate version, creating it if necessary}$
  \COMMENT{aborts all non-appropriate versions found}
\IF{$o\ptr\code{field}[n] \neq \code{FLAG\_VALUE}$}
  \STATE watch for races here
  \STATE copy current value somewhere (how far over?)
  \STATE $o\ptr\code{field}[n] \gets \code{FLAG\_VALUE}$
\ENDIF
\STATE $v\ptr\code{field}[n] \gets x$
\end{myalgorithmic}
\caption{Algorithm for transactional write of a field.}
\label{fig:writetrans}
\end{figure}

\begin{figure}
$\text{StateP}(\code{struct commitrec *} c)$ =
\begin{myalgorithmic}
\LOOP
  \IF{$c = \code{null}$}
    \RETURN \code{COMMITTED}
  \ENDIF
  \STATE $s \gets c \ptr\code{state}$
         \COMMENT{cache this read to prevent races}
  \IF{$s \neq \code{COMMITTED}$}
    \RETURN $s$
  \ENDIF
  \STATE $c \gets c \ptr \code{parent}$
\ENDLOOP*
\end{myalgorithmic}
\caption{Simple algorithm for determining transaction status.}
\label{fig:statep}
\end{figure}

\begin{figure}
$\text{StateP}'(\code{struct commitrec **} c_p)$ =
\begin{myalgorithmic}
\STATE $c \gets \code{*}c_p$
\STATE $s \gets \code{COMMITTED}$
\STATE $l \gets \code{false}$
\WHILE{$c \neq \code{null}$}
  \STATE $s \gets c\ptr\code{state}$ \COMMENT{atomic}
  \IF{$s \neq \code{COMMITTED}$}
    \BREAK
  \ENDIF
  \STATE $c \gets c \ptr \code{parent}$
  \STATE $l \gets \code{true}$
\ENDWHILE
\IF[$l$ indicates a change has been made]{$l$}
  \STATE $\code{*}c_p \gets c$ \COMMENT{atomic}
\ENDIF
\RETURN $\tuple{s,l}$
\end{myalgorithmic}
\caption{Improved algorithm for determining transaction status ---
         does pruning.}
\label{fig:statepprime}
\end{figure}

\begin{figure}
$\text{AbortTransaction}(\code{struct commitrec *} c)$ =
\begin{myalgorithmic}
\IF{$c = \code{null}$}
  \RETURN \code{COMMITTED}
\ENDIF
\LOOP
  \STATE $s \gets c\ptr\code{state}$
  \IF{$s \neq \code{WAITING}$}
    \RETURN $s$
  \ENDIF
  \STATE $\code{compare\_and\_swap}(\&c\ptr\code{state}, s, \code{ABORTED})$
         \label{line:abort}
\ENDLOOP*
\end{myalgorithmic}
\caption{Algorithm for (possibly) aborting a transaction.
         Change the constant \code{ABORTED} in line \ref{line:abort}
         to \code{COMMITTED} to obtain the commit algorithm.}
\label{fig:aborttrans}
\end{figure}

%% XXX: separate transactions?  parallel subtransactions?
%% XXX: can I have two reads outstanding on an object? (yes?)

%\begin{figure}
%\begin{alltt}\codesize
%\end{alltt}
%\caption{}
%\label{fig:}
%\end{figure}

\bibliography{harpoon}
\end{document}