%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Various journal and conference string definitions:
@string{CACM = {Communications of the ACM}}
@string{ACM =  {ACM}}
@string{IEEE = {IEEE}}
@string{ICCAD  = "Proceedings of the {IEEE}/{ACM} International Conference on
                  Computer Aided Design ({ICCAD})"}
@string{PLDI93 = "Proceedings of the {ACM} {SIGPLAN} '93 Conference on
                  Programming Language Design and Implementation ({PLDI})"}
@string{PLDI94 = "Proceedings of the {ACM} {SIGPLAN} '94 Conference on
                  Programming Language Design and Implementation ({PLDI})"}
@string{PLDI95 = "Proceedings of the {ACM} {SIGPLAN} '95 Conference on
                  Programming Language Design and Implementation ({PLDI})"}
@string{PLDI96 = "Proceedings of the {ACM} {SIGPLAN} '96 Conference on
                  Programming Language Design and Implementation ({PLDI})"}
@string{PLDI97 = "Proceedings of the {ACM} {SIGPLAN} '97 Conference on
                  Programming Language Design and Implementation ({PLDI})"}
@string{POPL94 = "Proceedings of the 21st {ACM} Symposium on Principles
                  of Programming Languages ({POPL})"}
@string{POPL98 = "Proceedings of the 25th {ACM} Symposium on Principles
                  of Programming Languages ({POPL})"}
@string{TOPLAS = "{ACM} Transactions on Programming Languages and Systems"}
@string{ASIAN97 = "Advances in Computing Science --- ASIAN '97.  Third
                  Asian Computing Conference.  Proceedings"}
@string{TACAS97 = "Tools and Algorithms for the Construction and
                  Analysis of Systems.  Third International Workshop,
                  TACAS '97.  Proceedings"}
@string{CRYPTO97 = "Proc.\ CRYPTO 97"}
@string{EUROCRYPT97 = {Proc.\ EUROCRYPT 97}}

% papers read.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Language issues.

%%%%%%% Esterel.

@InProceedings{gagne97:nonstandard,
  author = 	 {Jean-Raymond Gagn{\'e} and John Plaice},
  title = 	 {The Non-standard Semantics of {Esterel}},
  booktitle = 	 ASIAN97,
  year = 	 1997,
  address = 	 {Kathmandu, Nepal},
  pages =	 {381-382},
  annote =	 {Presents rationale for using a (time+delta) timeline
                  instead of Esterel's integer-valued instantaneous
                  time model.  Claims that Esterel really uses the
                  (time+delta) timeline without realizing it.}
}

@InCollection{berry92:hardware_esterel,
  author = 	 {G{\'e}rard Berry},
  title = 	 {{Esterel} on hardware},
  booktitle = 	 {Mechanized Reasoning and Hardware Design},
  pages =	 {87-103},
  publisher =	 {Prentice Hall},
  year =	 1992,
  editorIGNORE =	 {C.A.R. Hoare and M.J.C. Gordon},
  annote =	 {a simple hardware implementation of a subset of
                  esterel, using 4 type of fundamental logic blocks.
                  Optimizers based on BDDs.  Very useful bibliography.}
}

@Unpublished{berry:esterel_primer,
  author = 	 {G{\'e}rard Berry},
  title = 	 {The {Esterel} v5 Language Primer},
  note = 	 {Available from 
                 \texttt{http://www.inria.fr/meije/esterel/esterel-eng.html}},
  month = 	 mar,
  year = 	 1998,
  url = 	 {ftp://ftp-sop.inria.fr/meije/esterel/papers/primer.ps.gz},
  annote = 	 {Lots of dry technical detail on the language, but
                  also some enlightening discussion of the rationale
                  behind it.  See especially sections on
                  `Transformational, Interactive, and Reactive
                  Systems,' `Write Things Once,' and preemption.}
}

@InProceedings{berry97:synth_opt_ver_esterel,
  author = 	 {G{\'e}rard Berry},
  title = 	 {Hardware and Software Synthesis, Optimization, and
                  Verification from {Esterel} Programs},
  booktitle = 	 TACAS97,
  year = 	 1997,
  address = 	 {Enschede, The Netherlands},
  pages =	 {1-3},
  month =	 apr,
  annote =	 {Two-page overview of the Esterel system.  At least
                  it has a decent bibliography.}
}

%%%%%%% Other synchronous languages

@InProceedings{amagbegnon95:signal,
  author = 	 {Pascalin Amagb{\'e}gnon and Lo{\"\i}c Besnard and
                  Paul Le Guernic},
  title = 	 {Implementation of the Data-flow Synchronous Language
                  {SIGNAL}},
  booktitle = 	 PLDI95,
  year =	 1995,
  address =	 {La Jolla, California},
  month =	 Jun,
  pages =	 {163-173},
  url = 	 {http://www.acm.org/pubs/articles/proceedings/pldi/},
  annote =	 {Not terribly useful.  Intriguing use of the word
                  'arborescent' for 'tree-structured'.}
}

@Article{chung95:language_constructs,
  author = 	 {Tai M. Chung and Hank G. Dietz},
  title = 	 {Language Constructs and Transformation for Hard
                  Real-time Systems},
  journal = 	 {{ACM} {SIGPLAN} Notices},
  year = 	 1995,
  volume =	 30,
  number =	 11,
  pages =	 {41-49},
  month =	 nov,
  note =	 {Presents a simple set of language-independent
                  extensions to specify real-time constraints.  Also
                  contains the interesting claim that the compilation
                  problems are solved, and references an unpublished
                  paper to prove it.}
}

%%%%%%% Other language issues.


%%%%%%% Compiler issues

@InProceedings{weise94:vdg,
  author = 	 {Daniel Weise and Roger F. Crew and Michael Ernst and
                  Bjarne Steensgaard},
  title = 	 {Value Dependence Graphs: Representation without Taxation},
  booktitle = 	 POPL94,
  year =	 1994,
  address =	 {Portland, Oregon},
  month =	 Jan,
  pages =	 {297-310},
  annote =	 {dataflow representation useful; also resursive/loop
                  structure useful},
  url = 	{ftp://research.microsoft.com/pub/papers/vdg.ps}
}

@InProceedings{hong93:realtime,
  author = 	 {Seongsoo Hong and Richard Gerber},
  title = 	 {Compiling Real-Time Programs into Schedulable Code},
  booktitle = 	 PLDI93,
  year =	 1993,
  address =	 {Albuquerque, New Mexico},
  month =	 jun,
  pages =	 {166-176},
  url = 	 {http://www.acm.org/pubs/articles/proceedings/pldi/},
  annote =	 {code motion for timing optimization.  Are all
                  real-time schedulers iterative?}
}

@InProceedings{duesterwald93:arrayflow,
  author = 	 {Evelyn Duesterwald and Rajiv Gupta and Mary Lou Soffa},
  title = 	 {A Practical Data Flow Framework for Array Reference
                  Analysis and its Use in Optimizations},
  booktitle = 	 PLDI93,
  year =	 1993,
  address =	 {Albuquerque, New Mexico},
  month =	 jun,
  pages =	 {68-77},
  url = 	 {http://www.acm.org/pubs/articles/proceedings/pldi/},
  annote =	 {not terribly useful.  REREAD LATER.}
}

@InProceedings{click95:IR,
  author =       {Cliff Click and Michael Paleczny},
  title =        "A Simple Graph-Based Intermediate Representation",
  booktitle =    "The First {ACM} {SIGPLAN} Workshop on Intermediate
                 Representations",
  address =      "San Francisco, California",
  month =        jan,
  year =         "1995",
  url =          {http://www.cs.rice.edu/~mpal/IR95.ps},
  annote =	 {interesting examples of C++ code, but light on
                  optimization results.  We really want to peek at
                  Cliff Click's PhD thesis.}
}

@InProceedings{sreedhar96:dj,
  author = 	 {Vugranam C. Sreedhar and Guang R. Gao and {Yong-fong} Lee},
  title = 	 {A New Framework for Exhaustive and Incremental Data
                  Flow Analysis Using {DJ} Graphs},
  booktitle = 	 PLDI96,
  year =	 1996,
  address =	 {Philadelphia, Pennsylvania},
  month =	 may,
  pages =	 {278-290},
  url = 	 {http://www.acm.org/pubs/citations/proceedings/pldi/231379/p278-sreedhar/},
  annote =	 {Emphasis on Incremental.  If we decide to use DJ
                  graphs, this paper could be useful for its examples.
                  Not much new, though, compared to the N other DJ
                  graph papers these authors have cranked out.}
}

@Article{sreedhar97:domtree,
  author = 	 {Vugranam C. Sreedhar and Guang R. Gao and
                  {Yong-fong} Lee},
  title = 	 {Incremental Computation of Dominator Trees},
  journal = 	 TOPLAS,
  year = 	 1997,
  volume =	 19,
  number =	 2,
  month =	 mar,
  pages =	 {239-252},
  url =		 {http://www.acm.org/pubs/citations/journals/toplas/1997-19-2/p239-sreedhar/},
  annote =	 {Seems to work well, but I don't think we need
                  incremental updates for Harpoon.  Maybe I'm wrong.
                  Very similar to their other papers on this
                  topic. <wry grin>}
}

@InProceedings{granlund94:divopt,
  author = 	 {Torbj{\"o}rn Granlund and Peter L. Montgomery},
  title = 	 {Division by Invariant Integers using Multiplication},
  booktitle = 	 PLDI94,
  year =	 1994,
  address =	 {Orlando, Florida},
  month =	 jun,
  pages =	 {61-72},
  url = 	 {http://www.acm.org/pubs/citations/proceedings/pldi/178243/p61-granlund/},
  annote =	 {*Very* useful for eliminating logic complexity. Also
                  includes lots of references for deconstructing
                  multiplies. In conjunction with induction variable
                  analysis, some very powerful optimizations are
                  possible. The optimization of the radix conversion
                  code is nothing short of brilliant.}
}

@InProceedings{defouw98:classanal,
  author = 	 {Greg DeFouw and David Grove and Craig Chambers},
  title = 	 {Fast Interprocedural Class Analysis},
  booktitle = 	 POPL98,
  year =	 1998,
  address =	 {San Diego, California},
  month =	 jan,
  pages =	 {222-246},
  url =		 {http://www.acm.org/pubs/citations/proceedings/plan/268946/p222-defouw/},
  annote =	 {This basically tells us that class/type analysis
                  will be very slow.  We can make it faster, but we
                  lose much precision.  In hardware compilation we
                  don't care so much about speed, perhaps, so maybe we
                  just suck up and deal.  Return to this paper before
                  implementing our type inference engine. [theory
                  practice conflict: the idea I've got in my head
                  doesn't seem as slow as the fastest algorithm
                  presented here.  Reconcile this.]}
}

@InProceedings{click95:gcm_gvn,
  author = 	 {Cliff Click},
  title = 	 {Global Code Motion / Global Value Numbering},
  booktitle = 	 PLDI95,
  year =	 1995,
  address =	 {La Jolla, California},
  month =	 jun,
  pages =	 {246-257},
  url = 	 {http://www.acm.org/pubs/citations/proceedings/pldi/207110/p246-click/},
  annote =	 {Simple & works, but relies on heuristic to place,
                  and seems overly wedded to basic blocks (which we
                  want to eliminate).  I like SSAPRE better, even
                  though it is *much* more complicated.  Reassessment:
                  Maybe basic blocks aren't so bad.}
}

@InProceedings{chow97:ssapre,
  author = 	 {Fred Chow and Sun Chan and Robert Kennedy and
                  {Shin-Ming} Liu and Raymond Lo and Peng Tu},
  title = 	 {A New Algorithm for Partial Redundancy Elimination
                  based on {SSA} Form},
  booktitle = 	 PLDI97,
  year =	 1997,
  address =	 {Las Vegas, Nevada},
  month =	 may,
  pages =	 {273-286},
  url =		 {http://www.acm.org/pubs/citations/proceedings/pldi/258915/p273-chow/},
  annote =	 {Powerful but very, very complicated. Probably worth
                  implementing if we stay in SSA form, although
                  dataflow-based methods (see Click's IR) may be
                  simpler.  Also non-linear complexity for simple
                  implementations.}
}

@Article{click95:combin,
  author = 	 {Cliff Click and Keith D. Cooper},
  title = 	 {Combining Analyses, Combining Optimizations},
  journal = 	 TOPLAS,
  volume =	 17,
  number =	 2,
  year =	 1995,
  month =	 mar,
  pages =	 {181-196},
  url =          {http://www.acm.org/pubs/toc/Abstracts/0164-0925/201061.html},
  annote =	 {Very theoretical==not terribly useful.}
}

@Article{beck91:ctrlflow,
  author = 	 {Micah Beck and Richard Johnson and Keshav Pingali},
  title = 	 {From Control Flow to Dataflow},
  journal = 	 {Journal of Parallel and Distributed Computing},
  year = 	 1991,
  volume =	 12,
  number =	 2,
  month =	 jun,
  pages =	 {118-129},
  annote =	 {The paper that started it all.  Uses an
                  over-restrictive control model, though, and funky
                  store stuff.}
}

@Article{rinard97:commute,
  author = 	 {Martin C. Rinard and Pedro C. Diniz},
  title = 	 {Commutivity Analysis: A New Analysis Technique for
                  Parallelizing Compilers},
  journal = 	 TOPLAS,
  year = 	 1997,
  volume =	 19,
  number =	 6,
  month =	 nov,
  pages =	 {942-991},
  url =		 {http://www.acm.org/pubs/citations/journals/toplas/1997-19-6/p942-rinard/},
  annote =	 {Not terribly relevant to the current project, but
                  interesting nonetheless.  Perhaps we can perform
                  some commutivity analysis in Harpoon to free up parallelism?}
}

@Article{janssen97:cns,
  author = 	 {Johan Janssen and Henk Corporaal},
  title = 	 {Making Graphs Reducible with Controlled Node Splitting},
  journal = 	 TOPLAS,
  year = 	 1997,
  volume =	 19,
  number =	 6,
  month =	 nov,
  pages =	 {1031-1052},
  url =		 {http://www.acm.org/pubs/citations/journals/toplas/1997-19-6/p1031-janssen/},
  annote =	 {How to make any control flow graph reducible using a
                  minimum number of splits/duplicates.  VERY USEFUL if
                  we need reducible graphs.  (I suspect that the
                  properties of Java give us this for free.) Good results.}
}

@Article{gerlek95:inductssa,
  author = 	 {Michael P. Gerlek and Eric Stoltz and Michael Wolfe},
  title = 	 {Beyond Induction Variables: Detecting and
                  Classifying Sequences Using a Demand-Driven {SSA} Form},
  journal = 	 TOPLAS,
  year = 	 1995,
  volume =	 17,
  number =	 1,
  month =	 jan,
  pages =	 {85-122},
  url =		 {http://www.acm.org/pubs/citations/journals/toplas/1995-17-1/p85-gerlek/},
  annote =	 {Very powerful technique for induction variable
                  analysis using a variant of the SSA form.  Requires
                  a symbolic math package for full power, but can
                  accomplish classification easily.  mu and nu nodes
                  are used in addition to phi nodes; they might be
                  worthwhile subclasses.  Min/max bounds can often be
                  computed.  Useful useful stuff.  Reference to paper
                  on 'loop distribution' and 'loop interchanging' that
                  might be worthwhile to track down.  Implementable
                  algorithms.}
}

% Statecharts.

@InProceedings{mueller95:condbran,
  author = 	 {Frank Mueller and David B. Whalley},
  title = 	 {Avoiding Conditional Branches by Code Replication},
  booktitle = 	 PLDI95,
  year =	 1995,
  address =	 {La Jolla, California},
  month =	 jun,
  pages =	 {56--66},
  url =		 {http://www.acm.org/pubs/citations/proceedings/pldi/207110/p56-mueller/},
  annote =	 {Just what the title says.  Probably not useful for a
                  hardware compiler.  Only mildly useful in its
                  original domain, for that matter.}
}

@Article{harel92:overlap,
  author = 	 {David Harel and {Chaim-arie} Kahana},
  title = 	 {On Statecharts with Overlapping},
  journal = 	 {{ACM} Transactions on Software Engineering and Methodology},
  year = 	 1992,
  volume =	 1,
  number =	 4,
  month =	 oct,
  pages =	 {399-421},
  url =		 {http://www.acm.org/pubs/citations/journals/tosem/1992-1-4/p399-harel/},
  annote =	 {Here we basically learn that overlapping statecharts
                  are a Bad Thing.  Do not attempt.}
}

@Article{drusinsky89:hwsynth,
  author = 	 {Doron Drusinsky and David Harel},
  title = 	 {Using Statecharts for Hardware Description and Synthesis},
  journal = 	 {{IEEE} Transactions on Computer-Aided Design},
  year = 	 1989,
  volume =	 8,
  number =	 7,
  month =	 jul,
  pages =	 {798-807},
  annote =	 {A good description of what statecharts are, and a
                  variety of implementation methodologies using
                  various types of PLAs and FSMs.  The infamous
                  traffic light example.  Basic idea: implement
                  statecharts as multi-level Mealy/Moore machines.}
}

@Article{harel97:execobj,
  author = 	 {David Harel and Eran Gery},
  title = 	 {Executable Object Modeling with Statecharts},
  journal = 	 {Computer},
  year = 	 1997,
  volume =	 30,
  number =	 7,
  month =	 jul,
  pages =	 {31-42},
  url =		 {http://www.computer.org/computer/co1997/r7031abs.htm},
  annote =	 {Not useful at all.  A waste of time.  Although some
                  of the ideas of mapping methods to events are
                  similar to our approach.}
}

% HARDWARE SECTION

@InProceedings{aggarwal97:netpart,
  author = 	 {Rajat Aggarwal and Rajeev Murgai and Masahiro Fujita},
  title = 	 {Speeding Up Technology-Independent Timing
                  Optimization by Network Partitioning},
  booktitle = 	 ICCAD,
  year =	 1997,
  address =	 {San Jose, California},
  month =	 nov,
  pages =	 {83-90},
  url = 	 {http://www.acm.org/pubs/citations/proceedings/dac/266388/p83-aggarwal/},
  annote =	 {Useful, but presupposes a basic optimizer.  Some
                  good references to basic optimizers, which may prove
                  useful.  Presents a timing-driven partitioning technique.}
}

@InProceedings{bertacco97:disjunct,
  author = 	 {Valeria Bertacco and Maurizio Damiani},
  title = 	 {The Disjunctive Decomposition of Logic Functions},
  booktitle = 	 ICCAD,
  year =	 1997,
  address =	 {San Jose, California},
  month =	 nov,
  pages =	 {78-82},
  url =		 {http://www.acm.org/pubs/citations/proceedings/dac/266388/p78-bertacco/},
  annote =	 {Computationally very expensive. Enables creation of
                  a compact, canonical multi-level circuit directly
                  from a BDD representation, which is a Good
                  Thing. "We found the final netlist to be often close
                  to the output of more complex dedicated optimization
                  tools."  Probably worth implementing, or at least
                  researching further. BIG DRAWBACK: "For the largest
                  benchmarks, the limited set of BDD
                  transformations... do not compensate for the
                  exceptional growth of the BDD representation with
                  respect to the original representation."  I wish I
                  knew what the "original representation" was.}
}

@InProceedings{kukimoto97:xbd0,
  author = 	 {Yuji Kukimoto and Wilsin Gosti and Alexander
                  Saldanha and Robert K. Brayton},
  title = 	 {Approximate Timing Analysis of Combinational
                  Circuits under the {XBD0} Model},
  booktitle = 	 ICCAD,
  year =	 1997,
  address =	 {San Jose, California},
  month =	 nov,
  pages =	 {176-181},
  url =		 {http://www.acm.org/pubs/citations/proceedings/dac/266388/p176-kukimoto/},
  annote =	 {Good overview of timing analysis. Uses a SAT solver
                  to compute approximate timing. May be useful.}
}

@InProceedings{sarrafzadeh97:nrg,
  author = 	 {Majid Sarrafzadeh and Maogang Wang},
  title = 	 {{NRG}: Global and Detailed Placement},
  booktitle = 	 ICCAD,
  year =	 1997,
  address =	 {San Jose, California},
  month =	 nov,
  pages =	 {532-537},
  url =		 {http://www.acm.org/pubs/citations/proceedings/dac/266388/p532-sarrafzadeh/},
  annote =	 {Not enough detail given to be useful.}
}

@InProceedings{arikati97:signature,
  author = 	 {Srinivasa R. Arikati and Ravi Varadarajan},
  title = 	 {A Signature Based Approach to Regularity Extraction},
  booktitle = 	 ICCAD,
  year =	 1997,
  address =	 {San Jose, California},
  month =	 nov,
  pages =	 {542-545},
  url =		 {http://www.acm.org/pubs/citations/proceedings/dac/266388/p542-arikati/},
  annote =	 {The signature idea is a good one.  Not enough info
                  for an implementation, though.  And our regularity
                  information should come from a much higher
                  level. Might be worthwhile referencing to prove that
                  logic synthesis folk spend a lot of effort
                  reconstructing the high-level patterns thrown away
                  by the compiler. Not otherwise useful.}
}

@InProceedings{enos97:reppart,
  author = 	 {Morgan Enos and Scott Hauck and Majid Sarrafzadeh},
  title = 	 {Replication for Logic Bipartitioning},
  booktitle = 	 ICCAD,
  year =	 1997,
  address =	 {San Jose, California},
  month =	 nov,
  pages =	 {342-349},
  url =		 {http://www.acm.org/pubs/citations/proceedings/dac/266388/p342-enos/},
  annote =	 {We can create a better logic partition if we are
                  allowed to duplicate some logic.  Good idea and good
                  overview of partitioning methods.  VERY USEFUL if we
                  need to partition.  We want to use the Strawman
                  algorithm, apparently; we need to look up papers on it.}
}


@InProceedings{leiserson83:retiming,
  author = 	 {Charles E. Leiserson and Flavio M. Rose and James B. Saxe},
  title = 	 {Optimizing Synchronous Circuitry by Retiming},
  booktitle = 	 {Third Caltech Conference on Very Large Scale Integration},
  editor =	 {R. Bryant},
  year =	 1983,
  address =	 {Pasadena, California},
  month =	 mar,
  pages =	 {87-116},
  annote =	 {Three good references on other optimization types.
                  This paper describes how to optimize register
                  placement to obtain the smallest possible clock
                  cycle time. *DON'T HAVE COMPLETE PAPER*.
                  Useful. Includes algorithms to compute the clock
                  period of a circuit, among other things.}
}

@Article{malik91:retiming,
  author = 	 {Sharad Malik and Ellen M. Sentovich and Robert
                  K. Brayton and Alberto Sangiovanni-Vincentelli},
  title = 	 {Retiming and Resynthesis: Optimizing Sequential
                  Networks with Combinational Techniques},
  journal = 	 {{IEEE} Transactions on Computer-Aided Design},
  year = 	 1991,
  volume =	 10,
  number =	 1,
  month =	 jan,
  pages =	 {74--84},
  annote =	 {Useful extension of Leiserson's Retiming paper.
                  Perhaps more information can be found in malik93?
                  Basic idea is that we can push registers to the
                  periphery and disconnect cycles, optimize the
                  resulting circuit, and then push all the registers
                  back in and reconnect the feedback loops.  Makes
                  sense.  We still have to find a valid combinational
                  optimization technique to plug in the middle, though.}
}
