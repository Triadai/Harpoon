<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
     <TITLE>J2ME CDC Overview</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#000077" ALINK="#FF0000">

<TABLE BORDER="0" WIDTH="100%">
<TR>
<TD>
&nbsp;
<br>
<font size=-1> 
<a href="index.html">Contents</a> | Prev | <a href="build.html">Next</a>
</font></TD>

<TD align="right">
J2ME CDC 1.0 Beta
<br>Porting Guide
</TD>
</TR>
</TABLE>

<HR SIZE=2 NOSHADE>

<!-- ====================== Body text begins here ====================== -->
<h1>Introduction</h1>
<p>JavaTM 2 Platform, Micro Edition is the inner plumbing of Java technology on the Go!
</p>
<img src="JavaPlatform.gif" alt="">

<p>The JavaTM 2 Platform, Micro Edition (J2ME) technology is designed and architected to address the needs 
of a broad range of consumer electronic and embedded devices. J2ME supports 
environments targeted at consumer products. It provudes a framework for 
effectively organizing categories of devices and specifying environments 
for the categories.</p>

<h1>Architecture Overview</h1> 
<p>The J2ME architecture is based on two fundamental elements:</p>
<ul>
<li><b>Configuration</b>: a virtual machine and a minimal set of core class libraries 
and APIs. A configuration specifies a generalized runtime environment for 
consumer electronic and embedded devices.</li>
<li><b>Profile</b>: an industry-defined specification of the Java APIs used by 
manufacturers and developers to address a type of consumer electronic 
or embedded device.</li>
</ul>

<p>Together, a configuration and a profile deliver a specification for consumer 
electronics and embedded device manufactures to implement 
on their products. They provide a Java Application Environment to which 
third party developers can write their applications.</p>
<h1>J2ME Configurations</h1>
<p>Currently, J2ME offers two complementary configurations:</p>
<ul>
<li>Connected, Limited Device Configuration (CLDC)</li>
<li>Connected Device Configuration (CDC)</li>
</ul>
<p>Both are derived through the Java Community Process and targeted at 
different ends of the consumer electronics and embedded devices industry. 
</p>

<h2>CLDC Devices</h2>
<p>The Connected, Limited Device Configuration (CLDC) is intended for lower-end 
devices. Typically, these devices are battery powered, 
run a 16- or 32-bit RISC/CISC microprocessor/controller, with as little 
as 160Kb - 512Kb of total memory; 128Kb for the storage of the K virtual 
machine and libraries.</p>
<p>CLDC contains the K virtual machine (KVM). The KVM is a new virtual 
machine designed from the ground up and optimized with the constraints 
of inexpensive, lower-end devices. Named to reflect that its size is 
measured in terms of kilobytes, the KVM is suitable for these 
resource-constrained devices.</p>

<h2>CDC Devices</h2>
<p>The Connected Device Configuration (CLDC) is intended for higher-end, 
emerging, next generation devices. Typically, these devices run a 32-bit 
microprocessor/controller and contain more than 2.0Mb of total memory for 
the storage of the C virtual machine and libraries.</p>
<p>CDC contains the C virtual machine (CVM). The CVM is a full-featured, 
Java 2 "Blue Book" virtual machine; designed for devices needing the 
functionality of the Java 2 VM feature set. The CVM APIs are a superset 
of the KVM</p>

<h1>J2ME Profiles</h1>
<p>Currently, the following industry-defined profiles are available.</p>
<h2>Mobile Information Device Profile</h2>
<p>The Mobile Information Device Profile (MIDp) is a set of Java APIs 
that provide a complete J2ME application runtime environment targeted at 
mobile information devices, such as cellular phones and two-way pagers. 
This allows new applications and services to be dynamically deployed on the 
end user devices. The MIDp specification addresses issues such as user 
interface (UI), persistence storage, networking, and appliation model.</p>

<h2>Foundation Profile</h2>
<p>The Foundation Profile (FNDp) is a set of Java APIs intended for higher-end 
devices requiring a custom user interface (UI), which is typically provided 
by a device manufacturer. FNDp is designed to run with the Connected 
Device Configuration (CDC).</p>

<h2>Personal Profile</h2>
<p>The J2ME Personal Profile provides the J2ME environment for those devices 
with a need for a high degree of Internet connectivity and Web fidelity.</p>
<p>A Java Community Process (JCP) expert group has been convened to create 
an industry-defined user interface (UI) profile. Tentatively, this is 
being called the Personal Profile. This profile works in combination with 
CDC and FNDp.</p>

<h2>RMI Profile</h2>
<p>The J2ME RMI Profile provides Java platform to Java platform remote method 
invocation for Java devices and interoperates with J2SE RMI.</p>


<h1>CVM Feature Set</h1>
<p>The C Virtual Machine (CVM) is the basis for J2ME CDC and profiles. Many 
JVMs for desktops and servers do not scale well to embedded and consumer 
environments. </p>
<img src="CVM.gif" alt="">
<p>CVM is a new VM implementation for consumer and embedded systems.</p>
<ul>
<li>Complete Java 2 VM (Blue Book)</li>
<li>Small and reliable</li>
<li>More deterministic behavior</li>
<li>Modular and tunable</li>
<li>~256KB with JNI, reflection, verification, and class loading</li>
</ul>

<h2>Optimized Interpreter</h2>
The CVM interpreter optimizes:
<ul>
<li>Method calls and returns</li>
<li>Java synchronization support</li>
</ul>

<h2>Fast Java Synchronization</h2>
<p>The CVM uses light-weight locking if there is no contention. It uses just 
a couple of bits.</p>

<h2>Native Thread Support</h2>
<p>The CVM supports native threads and arbitrary thread pre-emption at machine 
instruction boundaries. It has proper internal synchronization, and handles 
exact garbage collection and Java synchronization correctly in the 
presence of pre-emptive native threading.</p>

<h2>Memory System</h2>
<p>The CVM memory system features the following:</p>
<ul>
<li>Exactness</li>
<li>Small average garbage collection pause times</li>
<li>Full separation of VM from the memory system</li>
<li>Pluggable garbage collectors</li>
<li>Generatinal garbage collection</li>
</ul>

<h2>ROMable Classes</h2>
<p>The CVM runs with "pre-loaded", mostly read-only classes. This provides 
better start-up time, less fragmentation, more data sharing, and the 
ability to execute byte-codes out of ROM.</p>

<h2>Small Class Footprint</h2>
<p>The small class footprint reduces loaded and ROMized class footprints to a 
minimum, about 40% compared to JDK classic and 17% compared to Personal 
Java.</p>

<h2>1.3 VM Support</h2>
<p>CVM supports the 1.3 VM features and libraries, including weak references, 
reflection, serialization, JNI, and RMI.</p>

<h2>Java 2 Security</h2>
<p>CVM supports Java 2 security.</p>

<h2>JPDA Support</h2>
<p>The JPDA support consists of:</p>
<ul>
<li>JVMDI support</li>
<li>Remote debugging support</li>
<li>Connect via Java Debug Wire Protocol (JDWP)</li>
</ul>

<h2>Portable</h2>
<p>The CVM is implemented in C, with very little assembler.</p>

<h2>Porting Layer</h2>
<p>The CVM contains a rich, well-documented porting layer. It is RTOS-aware, 
supports multiple porting options (for the tricky stuff), and provides the 
bare minimum left to the porter for fast re-targeting.</p>

<h2>Hardened System</h2>
<p>The "hardened" system in low memory cases ensures that failures such as 
out of memory and out of file descriptors are handled gracefully.</p>

<h2>Stack Usage</h2>
<p>The CVM utilizes deterministic and limited stack usage.</p>
<ul>
<li>Static analysis on the executable reduces C recursion to a minimum.</li>
<li>Stack checks for the few remaining recursion cases prevent stack overflow.</li>
<li>Reduced native stack usage wherever possible.</li>
</ul>
<h2>Startup and Shutdown</h2>
<p>The CVM provides ordered shutdown and re-startability.</p>
<ul>
<li>Clean shutdown and re-start of our VM in the same address space 
(e.g., on a RTOS), without help from a process model.</li>
<li>Free up all our memory and stop all our threads without any leaks on 
VM shutdown.</li>
<li>Re-initialize correctly on VM re-start.</li>
</ul>

<h2>Interfaces</h2>
<p>The CVM provides extensible and well-defined interfaces.</p>
<ul>
<li>The interfaces between components, like garbage collection, type system, 
locking and interpreter are clearly defined, well-separated, and well-documented.</li>
<li>It is much easier to add new features to CVM compared to the previous 
Personal Java Virtual Machine.</li>
</ul>










<!-- Body text ends here -->
<!-- ============================================================== -->
<hr SIZE=2 NOSHADE>
<font size=-1> 
<a href="index.html">Contents</a> | Prev | <a href="build.html">Next</a>
</font>

<HR SIZE=2 NOSHADE>

<TABLE BORDER="0" WIDTH="100%">
<TR VALIGN=TOP>

<TD>
<FONT SIZE="-2">
   <A HREF="../legal/SMICopyright.html">Copyright</A> &#169; 2000
   <A HREF="http://www.sun.com/">Sun Microsystems, Inc.</A>
    All Rights Reserved.</FONT>
   <br>
   <br>

   <FONT SIZE="-1">
   Please send comments to: <a href="mailto:jcp-cdc-comments@eng.sun.com">
   jcp-cdc-comments@eng.sun.com</a> 
   </FONT>
</TD>

<TD ALIGN=RIGHT>
   <IMG SRC="../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 WIDTH=64 HEIGHT=30>
</TD>

</TR>
</TABLE>

</BODY>
</HTML>

