// DisjointSetStructure.java, created Mon Jan 10 13:22:33 2000 by pnkfelix
// Copyright (C) 1999 Felix S. Klock <pnkfelix@mit.edu>
// Licensed under the terms of the GNU GPL; see COPYING for details.
package harpoon.Util.Collections;

import harpoon.Util.Util;
import harpoon.Util.UnmodifiableIterator;

import java.util.Set;

/**
 * <code>DisjointSetStructure</code> is a <code>SetFactory</code> that
 * produces sets suitable for grouping n distinct elements into a
 * collection of disjoint sets.
 *
 * Implementation is based on the description in <i>Introduction to
 * Algorithms</i>, by Cormen, Leiserson, and Rivest, in Chapter 22,
 * "Data Structures for Disjoint Sets"
 *
 * The main difference is that instead of using an element of the Set
 * as its 'representative', to use CLR's terminology, we use the
 * references to the individual sets as their representative.  This
 * raises some issues (for example, the ability to have a
 * representative for an empty set).
 *
 * The sets produced are actually of type 'Set[ Elem[ T ] ]' , where 'T'
 * is the generic type that the user wishes to collect.  Thus several 
 * standard operations, such as <code>contains(Object)</code> will not
 * be able to be used on the Sets returned.  To work around this, a 
 * standardView(Set s) method is provided, which, given a set
 * produced by <code>this</code> of type 'Set[ Elem[ T ] ]', will return
 * a view of <code>s</code> of type 'Set[ T ]'.
 * 
 * @author  Felix S. Klock <pnkfelix@mit.edu>
 * @version $Id: DisjointSetStructure.java,v 1.1.2.3 2000-01-14 12:33:02 cananian Exp $
 */
public abstract class DisjointSetStructure { 
    // note: having this extend SetFactory doesn't make sense any
    // more to me; to properly implement the functionality mandated by
    // the SetFactory interface, one must sacrifice the benefits of
    // using the data structures presented for Disjoint Sets.
    
    /** <code>Elem</code> is a wrapper around an object that is an
	element of this.
     */
    public abstract class Elem { 
	protected final Object member;
	protected Elem(Object m) { this.member = m; }
	public String toString() {
	    return "Elem[ member:"+member+" ]";
	}
    } 
    
    /** Returns a <code>java.util.Set</code> view of the
	set represented by <code>rep</code>.
	<BR> <B>requires:</B> <code>rep</code> currently is the
	     representative for some set maintained by
	     <code>this</code>. 
	<BR> <B>effects:</B> returns an unmodifiable view of the set
	     represented by <code>rep</code>. 
	<BR> <B>mandates:</B> Code using the <code>Set</code> returned
	     must ensure that <code>rep</code> remains a valid
	     representative for a set maintained by this.  Usually
	     this entails that as long as the <code>Set</code>
	     returned is accessible, <code>this.union(x,y)</code>
	     should not be called with <code>rep</code> as one of the 
	     arguments.
    */
    public abstract Set setView(Elem rep);

    /** Generates a new set containing <code>o</code>.
	<BR> <B>requires:</B> <OL>
	     <LI> <code>o</code> cannot be a member of any other set
	          previously generated by this factory (to avoid
		  breaking the Disjointness property). 
	     </OL>
	<BR> <B>effects:</B> Constructs a new singleton set containing
	     <code>o</code>, and returns the representative for the
	     newly constructed set.
    */
    public abstract Elem makeSet(Object o);
    
    /** Generates the union of the sets represented by <code>x</code>
	and <code>y</code>.  
	<BR> <B>requires:</B> <code>x</code> and <code>y</code> are
   	     both representatives of sets that have been generated by
	     <code>this</code>.
        <BR> <B>modifies:</B> <code>this</code>, <code>x</code>,
	                      <code>y</code>. 
	<BR> <B>effects:</B> Generates a new set that is the union of
	     the sets represented by <code>x</code> and
	     <code>y</code>, discards the sets represented by
	     <code>x</code> and <code>y</code> from the collection of
	     disjoint sets maintained by <code>this</code>, and
	     returns the representative of the newly generated set.
	<BR> <B>mandates:</B> code using this method should cease
	     using <code>x</code> and <code>y</code> as
	     representatives of any set, because they are not
	     guaranteed to properly represent any set maintained by
	     this after this method is called. 
    */
    public abstract Elem union(Elem x, Elem y);

    /** Returns the representative for the set containing
	<code>elem.member</code>.    
	<BR><B>requires:</B> <code>elem</code> was generated by
	     <code>this</code>. 
	<BR><B>effects:</B> Finds the set, S, containing the element
	    <code>elem.member</code>, and returns the representative
	    for S. 
    */
    public abstract Elem findSet(Elem elem);

}
