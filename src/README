# Alex Salcianu <salcianu@alum.mit.edu> November 2005
# $Id: README,v 1.5 2005-11-21 18:58:26 salcianu Exp $

This directory contains the architecture-independent C source files
for the runtime.


TOP LEVEL FILES:


config_checker.c

  Part of a technical hack to cause meaningful link error
  messages if the configuration of the Flex compiler and the
  configuration of the Flex runtime are different.  Here is how it
  works: the Flex compiler generates native / precise-c code that
  contains references to variables whose names encode the different
  config options.  The file config_checker.c uses some macros to
  generate declarations for variables whose names are based on the config
  options.  Differences in configs cause the references from the code
  generated by Flex not to be matched by any declaration.


startup.c
  
  Contains the main procedure of the generated native program.  This
  procedure executes some code and next invokes the compiled version
  of the main method of the compiled Java application.  It's a good
  place to add some [calls to] initialization code (if you need
  something like this, for your optimization / dynamic analysis).


-----------------------------------------------------------------------


SUBDIRS WITH ESSENTIAL PARTS:


classpath/

  The Java standard library requires some runtime support; e.g.,
  the runtime has to implement all code that manipulates directly the
  object layout.  The specification for the required code is documented
  in the vmintegration.info file that comes with the GNU Classpath.


sunjdk/

  Similar to classpath above, but for the Sun JDK 1.1.8 standard
  library.


gc/

  Implementation of several Precise Garbage Collectors by Karen K. Zee
  and a few UROPs.  By default, Flex uses the conservative (i.e.,
  imprecise) BDW GC (theoretically, BDW collects fewer objects,
  because it does not know exactly which fields are pointers and which
  are not; however, BDW is quite well tested - debugging and tuning a
  GC is very hard ...)


java.lang/

  Factors out some code that is invoked from both classpath/ and
  sunjdk/ above.  E.g., both classpath/java.lang/java_lang_VMSystem.c
  and sunjdk/java.lang/java_lang_System.c call the function
  fni_system_arraycopy that is defined in java.lang/system.h.  Notice
  that the functions from system.h are not necessarily native methods
  from java.lang.System; all we can say is that java.lang contains
  native methods that may be called from java.lang.* classes.


java.lang.reflect/

  Reflection-related Java classes and C native code required for
  the support of both GNU Classpath (classpath/) and Sun JDK 1.1.8
  (sunjdk/) standard library.


jni/

  Flex implementation of the Java Native Interface (JNI).  JNI
  documentation is available from

    http://java.sun.com/j2se/1.4.2/docs/guide/jni
    http://java.sun.com/docs/books/tutorial/native1.1

  jni-vtable.c contains the big top-level structure
  "JNINativeInterface FLEX_JNI_vtable": a structure containing
  function pointers to all user-level JNI methods.  The rest of the
  files in jni/ contain implementation of these functions, e.g.,
  jni-field.c defines (among other things) FNI_SetStaticObjectField.


-----------------------------------------------------------------------


SUBDIRS WITH ADDITIONAL PARTS (RELATED TO SPECIAL USES / OPTIMIZATIONS):


debug/

  Debugging code for the some stack inspecton mechanism used for
  exception support in the native back-ends.  Irrelevant for the
  precise-c backend ([AS]: Scott, please correct me if I'm wrong).


cam/
servo/

  Runtime code for some old (2002-2003?) DARPA demo prepared involving
  a Compaq IPaq that controls a robot with servomechanisms (for
  mobility) and video cameras (for orientation).


clheap/

  "Clustered Heap Support": code written by C. Scott Ananian for the
  stack and thread allocation optimizations enabled by Alex Salcianu's
  pointer analysis implementation (see Alex's SM thesis for the pa
  algorithm).


dynsync/

  Code written by C. Scott Ananian for the "dynamic" synchronization
  removal optimization enabled by Alex Salcianu's pointer analysis
  implementation.  Why "dynamic"?  The pointer analysis is purely
  static: it modifies the allocation sites that allocate only local
  objects to mark a special flag (with the meaning "is local") in the
  object header.  At runtime, each sync operation tests this flag: if
  true, the real sync code (that may be very costly) is bypassed.


mzf/

  Runtime code for C. Scott Ananian's "mostly zero fields" (mzf)
  program optimization.


nativeio/

  Runtime code that implements (async?) I/O operations for the event
  driven project - see Brian Demsky's master thesis (MIT, June 2001);
  I don't think the code changed significantly since then.


realtime/
rtjperf/

  Runtime code for Wes Beebee's implementation of the Real Time
  Specification for Java.


roles/
  
  Runtime code for Brian Demsky's role inference project (see Brian's
  list of publications, he had an ICSE paper about this project).


stats/

  Runtime code that gathers a few statistics (most of them memory
  stats, e.g., stack/heap alloc size)


transact/

  Runtime code for C. Scott Ananian's software transaction project
  (please see Scott's list of publications).


user/

  Runtime code for user-level threads; relevant if the Runtime is
  configured with --with-thread-model=user
   




