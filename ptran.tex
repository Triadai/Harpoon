% -*-latex-*- This is a LaTeX document.
% $Id: ptran.tex,v 1.5 2002-07-23 22:50:36 cananian Exp $
\documentclass[11pt,notitlepage]{article}
\usepackage{comdef} % common definitions
\usepackage{pdffonts} % PDF-friendly fonts
\usepackage{stmaryrd} % for \rrbracket and \llbracket
\author{C.~Scott~Ananian}
\title{Points-To Analysis with Companion Objects}
\date{\today \\ $ $Revision: 1.5 $ $}

\begin{document}
\bibliographystyle{abbrv}
\maketitle
\section{Singular Values}

We say a program variable $v$ is \newterm{singular} at a statement $s$
if $v$ will have a different value at every execution of $s$.  An
allocation site \code{a = new A()} produces a value which is singular
at the site; other defintions of $a$ might reach other statements
$s_x$ in the program, so $a$ is not guaranteed to be singular at $s_x$.

A variable $v_1$ singular at a statement $s_1$ is
\newterm{pairwise-singular} with a variable $v_2$ singular at a statement
$s_2$ iff no value of $v_1$ at an execution $s_1$ is ever equal to any
value of $v_2$ at an execution of $s_2$.

Now we can say that a set $S$ of statements is
\newterm{mutually-singular} iff
\begin{displaymath}
%\begin{eqnarray}\lefteqn{
\forall s_1 \in S, s_2 \in S, v_1 \in \text{use}(s_1), v_2 \in \text{use}(s_2),
  s_1 \neq s_2 :
%} \\ & &
v_1 \text{ at } s_1 \text{ is pairwise-singular with } v_2 \text{ at } s_2
%\end{eqnarray}
\end{displaymath}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We can compute singularity using a dataflow algorithm as follows.
Let $\text{SIN}(P)$ be the set of variables which are singular
at program point $P$.  We will use an auxillary function
$\text{USE}(v, P)$ be the set of uses of $v$ possibly executed before
point $P$.  For statements at point $P$ we have the rules:
\begin{displaymath}
\begin{array}{lll}
v_0 = \text{new } T & v_0 \in \text{SIN}_{\text{out}}(P)
                    & \text{USE}_{\text{out}}(v_0, P) = \emptyset \\
v_0 = v_1 & v_0 \in \text{SIN}_{\text{out}}(P) \text{ iff }
            v_1 \in \text{SIN}_{\text{out}}(P)
          & P \in \text{USE}_{\text{out}}(v_1, P) \\

%
%v = \ldots & \text{BSY}_{\text{in}}(v,P)=\code{false} \\
%\ldots = v & \text{BSY}_{\text{in}}(v,P)=\code{true} \\
%x=\phi(y_0,\ldots,y_n) &
%       \text{BSY}_{\text{in}}(y_i,P)=\text{BSY}_{\text{out}}(x,P) \\
%\tuple{x_0,\ldots,x_n}=\sigma(y) &
%       \text{BSY}_{\text{in}}(y,P)=\bigwedge_{i=0}^n \text{BSY}_{\text{out}}(x_i,P) \\
\end{array}
\end{displaymath}

We represent the analysis state as a tuple $\tuple{S, u}$, where $S
\subset V$ is the set of all variables $v \in V$ which are singular,
and $u:V \to 2^P$ is a function mapping each variable $v$ to the set
of uses seen for the variable.  We let $P$ be the set of all program
points.
The transfer function
$\tuple{S',u'} =
  \llbracket\text{\code{\textbf{st}}}\rrbracket (\tuple{S,u})$
defines the effect of each statement \code{st} on the analysis state.
We start the analysis with $tuple{S_0, u_0}$ where $S_0 = \emptyset$
and $u_0(v) = \emptyset$ for all $v \in V$.  Then we have:
\begin{displaymath}
\begin{array}{l}
\llbracket v_0 = \text{new } T \rrbracket (\tuple{S, u}) =
 \tuple{S \cup \{ v_0 \}, u'} \text{ where }
    u'(v) = \left\{\begin{array}{l}
      \emptyset \text{ if } v = v_0 \\
      u(v) \text{ otherwise} \\
    \end{array} \right.
\\
\llbracket v_0 = v_1 \rrbracket (\tuple{S, u}) =
 \tuple{S', u'} \text{ where }
   \begin{array}{rcl}
     S' &=& \left\{\begin{array}{l}
       S \cup \{ v_0 \} \text{ if } v_1 \in S \\
       S \text{ otherwise } \\
     \end{array} \right.
     \\
     u'(v) &=& \left\{\begin{array}{l}
        u(v) \cup \{ P \} \text{ if } v=v_1 \\
        u(v) \text{ otherwise } \\
     \end{array} \right.
   \end{array}
\\

\end{array}
\end{displaymath}

etc etc etc

The notion of singular variables is useful, but say we would like to
compare values at two statements $s_1$ and $s_2$.  Both use a variable
$v$ which is singular at both $s_1$ and $s_2$.  So we know that $v$
will have different values at $s_1$ for every execution of $s_1$, and
similarly for $s_2$.  But will the values of $v$ at $s_1$ be different
from the values of $v$ at $s_2$, or is there some execution of $s_2$
where $v$ has the same value as at some execution of $s_1$?  We say
$s_1$ and $s_2$ are \newterm{$v$-singular} in the first case.

To help determine this pair-wise statement singularity, we will label
singular values with the statement that created the values.  Given
statement $s_d : v = \text{new }T$, we say $v$ is \newterm{singular
  from $s_d$} after that point.  Thus the statement $s_1$ using $v$
which is singular from $s_x$, and statement $s_2$ using $v$ which is
singular from $s_y$, are pairwise $v$-singular if $s_x \neq s_y$.
If $s_x = s_y$, they may still be pairwise $v$-singular if $s_1$ is
not reachable from $s_2$ and $s_2$ is not reachable from $s_1$.  This
guarantees that no value generated from $s_x$/$s_y$ can be used at
both $s_1$ and $s_2$.

We can extend this in the obvious way to a set of statements.  A
set of statements is mutually $v$-singular if each individual pair of
statements in the set is $v$-singular.

Divorce this definition from one particular variable name by
identifying values by \textit{generation site}; values generated from
different generation sites are unique, regardless of what name they
are given.

Let us say that a statement is singular if the values used differ in
each execution.  A pair of statements is mutually singular if the
values used either come from different generation sites or cannot be
included in the same trace from the generation site.

We want all the ``set'' operations associated with edges from $A$ to $B$
to be mutually singular.

\section{Compositional Pointer Analysis}

\subsection{Evaluating a call-site monomorphically}
\subsection{Evaluating a call-site polymorphically}

\section{Allocating Polymorphism}

We evaluate sites polymorphically if they are factory methods, or
contain unbalanced companion objects.  Otherwise, the site is
evaluated monomorphically.

\section{Related Work}

Bod{\'\i}k et al outlined a method for detecting infeasible paths
in \cite{267921} which could be used to extend the set of statements
we determine are mutually singular (by enabling us to be less conservative).

Altucher et al renamed allocation sites for better alias analysis
precision on C programs with factory methods \cite{199466}.  They
do not handle Java or companion objects.

Collberg et al described a Java obfuscation technique that relies in
part on the intractability of alias analysis \cite{268962}.  The
analysis we describe is sufficient to break some of their predicates.
This could be used to construct a deobfuscator.  (These techniques
have been used in at least one commerical obfuscator \cite{humper02}.)


\bibliography{harpoon}
\end{document}
