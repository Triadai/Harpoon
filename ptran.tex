% -*-latex-*- This is a LaTeX document.
% $Id: ptran.tex,v 1.7 2002-07-24 02:24:57 cananian Exp $
\documentclass[11pt,notitlepage]{article}
%\documentclass{acmconf}
\usepackage{comdef} % common definitions
\usepackage{pdffonts} % PDF-friendly fonts
\usepackage{stmaryrd} % for \rrbracket and \llbracket
\author{C.~Scott~Ananian}
\title{Points-To Analysis with Companion Objects}
\date{\today \\ $ $Revision: 1.7 $ $}

\begin{document}
\bibliographystyle{abbrv}
\maketitle
\section{Singular Values}

We say a program variable $v$ is \newterm{singular} at a statement $s$
if $v$ will have a different value at every execution of $s$.  An
allocation site \code{a = new A()} produces a value which is singular
at the site; other defintions of $a$ might reach other statements
$s_x$ in the program, so $a$ is not guaranteed to be singular at $s_x$.

A variable $v_1$ singular at a statement $s_1$ is
\newterm{pairwise-singular} with a variable $v_2$ singular at a statement
$s_2$ iff no value of $v_1$ at an execution $s_1$ is ever equal to any
value of $v_2$ at an execution of $s_2$.

Now we can say that a set $S$ of statements is
\newterm{mutually-singular} iff
\begin{displaymath}
%\begin{eqnarray}\lefteqn{
\forall s_1 \in S, s_2 \in S, v_1 \in \text{use}(s_1), v_2 \in \text{use}(s_2),
  s_1 \neq s_2 :
%} \\ & &
v_1 \text{ at } s_1 \text{ is pairwise-singular with } v_2 \text{ at } s_2
%\end{eqnarray}
\end{displaymath}

We can compute a conservative approximation to singularity as follows.
We say a variable $v$ is singular at a use $s$ iff:
\begin{itemize}
\item all reaching definitions of $v$ are either allocation statements 
$v = \text{new }T(\ldots)$ or moves $v = x$ where $x$ is singular at
the move, and
\item every non-trivial path from $s$ to $s$ redefines $v$.
\end{itemize}

Let $\text{rd}(s,v)$ be the set of reaching definitions of $v$ at $s$.
We define the set of \newterm{generation sites} for a variable $v$ singular at
use $s$ as:
\begin{displaymath}
\text{GenSite}(s,v) %\text{ where } v\in\text{use}(s)
 =
\bigcup_{d \in \text{rd}(s,v)} g(d)
\text{ where }
g(d) = \left\{ \begin{array}{cl}
                \text{GenSite}(d,x) &\text{when } d \text{ is } v=x \\
		\{d\}&\text{when } d \text{ is } v=\text{new } T(\ldots)
                \end{array}\right.
\end{displaymath}

We can then approximate pairwise-singularity by saying $v_1$ at $s_1$
is pairwise-singular with $v_2$ at $s_2$ if either
there is no path from $s_1$ to $s_2$ or from $s_2$ to $s_1$, or
$\text{GenSite}(s_1,v_1) \cap \text{GenSite}(s_2,v_2) = \emptyset $.
An infeasible path analysis \cite{267921} could be used to refine
the path criterion.

\subsection{Intraprocedural singular value analysis}

An intraprocedural analysis to compute $\text{GenSite}(s, v)$ and the
singularity of individual variables can be built using the standard
dataflow framework:
\begin{eqnarray*}
\text{Out}(n)&=&\left(\text{In}(n)-\text{Kill}(n)\right)\cup\text{Gen}(n) \\
\text{In}(n)&=&\bigcup_{p\in\text{pred}(n)} \text{Out}(p)\\
\end{eqnarray*}

We let $\text{In}$ and $\text{Out}$ operate on tuples 
\tuple{\text{Rd},\text{Ns},\text{Ru},\text{Gs}} where $\text{Rd}(v)$ is the set
of reaching definitions of $v$ at $n$, $\text{Ns}(v)$ is a boolean
which is true iff $v$ is \textbf{non-}singular at $n$, $\text{Ru}(v)$
is a set of reaching \textbf{uses} of $v$ at $n$, and $\text{Gs}(v)$
is $\text{GenSite}(n, v)$, the set of generation sites of $v$ at $n$.
These relations are represented as sets of pairs \tuple{v, X} where
$\mathcal{R}(v)=X$ iff $\tuple{v,X} \in R$.  Each set is initialized
to the empty set, and grows monotonically as the analysis
progresses.  For clarity, we will separate out the Gen and Kill
functions for each component in the tuple, so that:
\begin{eqnarray*}
\text{Gen}(n) &=& \tuple{\text{Gen}_\text{Rd}(n),
                       \text{Gen}_\text{Ns}(n),
                       \text{Gen}_\text{Ru}(n),
                       \text{Gen}_\text{Gs}(n)} \\
\text{Kill}(n) &=& \tuple{\text{Kill}_\text{Rd}(n),
                       \text{Kill}_\text{Ns}(n),
                       \text{Kill}_\text{Ru}(n),
                       \text{Kill}_\text{Gs}(n)} \\
\end{eqnarray*}


\subsection{Interprocedural singular value analysis}

\section{Compositional Pointer Analysis}

\subsection{Evaluating a call-site monomorphically}
\subsection{Evaluating a call-site polymorphically}

\section{Allocating Polymorphism}

We evaluate sites polymorphically if they are factory methods, or
contain unbalanced companion objects.  Otherwise, the site is
evaluated monomorphically.

\section{Related Work}

Bod{\'\i}k et al outlined a method for detecting infeasible paths
in \cite{267921} which could be used to extend the set of statements
we determine are mutually singular (by enabling us to be less conservative).

Altucher et al renamed allocation sites for better alias analysis
precision on C programs with factory methods \cite{199466}.  They
do not handle Java or companion objects.

Collberg et al described a Java obfuscation technique that relies in
part on the intractability of alias analysis \cite{268962}.  The
analysis we describe is sufficient to break some of their predicates.
This could be used to construct a deobfuscator.  (These techniques
have been used in at least one commerical obfuscator \cite{humper02}.)


\bibliography{harpoon}
\end{document}
