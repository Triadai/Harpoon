% -*-latex-*- This is a LaTeX document.
% $Id: ptran.tex,v 1.38 2002-07-31 16:24:23 cananian Exp $
\documentclass[11pt,notitlepage]{article}
%\documentclass{acmconf}
\usepackage{comdef} % common definitions
\usepackage{pdffonts} % PDF-friendly fonts
\usepackage{stmaryrd} % for \rrbracket and \llbracket
\usepackage{amsmath}
\author{C.~Scott~Ananian}
\title{Points-To Analysis with Companion Objects}
\date{\today \\ $ $Revision: 1.38 $ $}

\newcommand{\bigvar}[1]{\ensuremath{\text{\it #1}}}
% boldface was kinda nice here:
\newcommand{\func}[1]{\ensuremath{\text{\sffamily #1}}}

\begin{document}
\bibliographystyle{abbrv}
\maketitle
\section{Terms} % should be section 0?
We will use $v\in V$ for variables and $s\in S$ for statements.  The
function $\func{use}:S\to 2^V$ returns the set of variables whose
values are used in a given statement; the function $\func{def}:S\to
2^V$ similarly reports variables defined at a statement point.
We call a tuple \tuple{v,s} a \newterm{static value}, as it represents
a variable's possible values at a given program point.%
\footnote{As opposed to a ``dynamic value'', which would represent the
  unique value of the variable at a given moment during a possible execution.}

\section{Singular Values}

We say a program variable $v$ is \newterm{singular} at a statement $s$
if $v$ will have a different value at every execution of $s$.  An
allocation site $a = \text{\tt new }A$ produces a value which is singular
at the site; other defintions of $a$ might reach other statements
$s_x$ in the program, so $a$ is not guaranteed to be singular at $s_x$.

A variable $v_1$ singular at a statement $s_1$ is
\newterm{pairwise-singular} with a variable $v_2$ singular at a statement
$s_2$ iff no value of $v_1$ at an execution $s_1$ is ever equal to any
value of $v_2$ at an execution of $s_2$.

Now we can say that a set of static values
$\bigvar{SV}=\left\{ \tuple{v,s} | v \text{ is singular at } s \right\}$
is
\newterm{mutually-singular} iff
\begin{displaymath}
\forall \left\{ \tuple{v_1,s_1}, \tuple{v_2,s_2} \right\} \subseteq
        \bigvar{SV} :
v_1 \text{ at } s_1 \text{ is pairwise-singular with } v_2 \text{ at } s_2
\end{displaymath}
Note that $s_1$ and $s_2$ can be the same statement as long as $v_1\neq v_2$.

We can compute a conservative approximation to singularity as follows.
We say a variable $v$ is singular at a use $s$ iff:
\begin{itemize}
\item all reaching definitions of $v$ are either allocation statements 
$v = \text{\tt new }T$ or moves $v = x$ where $x$ is singular at
the move, and
\item every non-trivial path from $s$ to $s$ redefines $v$ (where a
  non-trivial path traverses at least one edge).
\end{itemize}

Let $\func{RD}(\tuple{v,s})$ be the set of (intraprocedural) reaching
definitions
of $v$ at $s$.
We define the set of \newterm{generation sites} for a variable $v$ singular at
use $s$ as:
\begin{displaymath}
\func{GenSite}(\tuple{v,s}) %\text{ where } v\in\func{use}(s)
 =
\bigcup_{d \in \func{RD}(\tuple{v,s})} \func{g}(d)
\text{ where }
\func{g}(d) = \begin{cases}
                \func{GenSite}(\tuple{x,d}) &\text{when } d \text{ is } v=x \\
                \{d\}&\text{when } d \text{ is } v=\text{\tt new } T
       \end{cases}
\end{displaymath}

We can then approximate pairwise-singularity by saying $v_1$ at $s_1$
is pairwise-singular with $v_2$ at $s_2$ if
\begin{displaymath}
\neg\exists d \in \func{GenSite}(\tuple{v_1,s_1}) \cap \func{GenSite}(\tuple{v_2,s_2})
     : \func{Path}_{\mathcal{G}-d}(s_1, s_2) \vee
       \func{Path}_{\mathcal{G}-d}(s_2, s_1)
\end{displaymath}
where $\func{Path}_{\mathcal{G}-z}(x, y)$ is true iff there is a path
from $x$ to $y$ in directed control-flow graph $\mathcal{G}$ which
does not pass through $z$.  Note that
$\func{Path}_\mathcal{G}(x,y)$ is true if $x=y$.
An infeasible path analysis \cite{267921} could be used to refine
this predicate by excluding paths never traversed by any
execution of the program.
% note that a statement ... = a + b *could* however have a=b and still
% be singular.  does this need to be fixed?

\begin{myfigure}[p]
\begin{samplecode}[2]%
while (\ldots) \{         &while (\ldots) \{         \\
\>v = new T(\ldots)       &\>v1 = new T(\ldots)      \\
\>if (\ldots)             &\>if (\ldots)             \\
\>\>\ldots = v;  /* s1 */ &\>\>v2 = v1;              \\
\>else                    &\>if (\ldots)             \\
\>\>\ldots = v;  /* s2 */ &\>\>\ldots = v2;  /* s3 */ \\
\}                        &\>else                    \\
                          &\>\>\ldots = v2;  /* s4 */ \\
                          &\}                        \\
\end{samplecode}%
\caption{Statements $s_1$ and $s_2$ are pairwise-singular in the code
  on the left; statements $s_3$ and $s_4$ are not singular because
  there exist paths $s_3\pathplus s_3$ and $s_4\pathplus s_4$ which do not
  redefine \texttt{v2}.}
\label{fig:pairwise-singular}
\end{myfigure}

\subsection{Intraprocedural singular value analysis}

An intraprocedural analysis to compute $\func{GenSite}(\tuple{v,s})$ and the
singularity of individual variables can be built using the standard
dataflow framework:
\begin{eqnarray*}
\func{Out}(n)&=&\left(\func{In}(n)-\func{Kill}(n)\right)\cup\func{Gen}(n) \\
\func{In}(n)&=&\bigcup_{p\in\func{pred}(n)} \func{Out}(p)\\
\end{eqnarray*}

We will perform the analysis simultaneously on three relations
$\func{Ru}$, $\func{Nd}$, and $\func{Gs}$.
The relations are represented as
sets of pairs \tuple{v, X} where
$\mathcal{R}(v)=X$ iff $\tuple{v,X} \in R$.
Both sets are initialized
to the empty set for all $n$, and grow monotonically as the analysis
progresses.
We let
$\func{Ru}(v)$ be the set of reaching \textbf{uses} of $v$ at $n$,
$\func{Nd}(v)$ be the set of \textbf{non-}singular reaching definitions
of $v$ at $n$,
 and
$\func{Gs}(v)$ be $\func{GenSite}(\tuple{v,n})$, the set of generation sites
of $v$ at $n$.
The appropriate Gen and Kill rules are:
\begin{eqnarray*}
% this is the standard reaching-def rule:
%\func{Gen}_\text{RD}(n) &=&
%       \left\{ \tuple{v, n} | v \in \func{def}(n) \right\} \\
%\func{Kill}_\text{RD}(n) &=&
%       \left\{ \tuple{v, s} | v \in \func{def}(n) \wedge
%                          \tuple{v,s} \in \func{In}_\text{RD}(n) \right\} \\
%%%%%%%%%%%%%%%%%%%%%%%%
\func{Gen}_\text{Ru}(n) &=&
        \left\{ \tuple{v, n} | v \in \func{use}(n) \right\} \\
\func{Kill}_\text{Ru}(n) &=&
        \left\{ \tuple{v, s} | v \in \func{def}(n) \wedge
                          \tuple{v,s} \in \func{In}_\text{Ru}(n) \right\} \\
%
% non-singular reaching defs of n.
\func{Gen}_\text{Nd}(n) &=&
        \left\{ \tuple{v, n} | v \in \func{def}(n) \wedge
\left( \func{IsBad}(n) \vee
\exists u\in\func{use}(n):\func{Ns}(u,n)
 \right) \right\}
\\
\func{Kill}_\text{Nd}(n) &=&
        \left\{ \tuple{v, s} | v \in \func{def}(n) \wedge
                          \tuple{v,s} \in \func{In}_\text{Nd}(n) \right\} \\
% gensites!
\func{Gen}_\text{Gs}(n) &=&
       \left\{ \tuple{v, n} | v \in \func{def}(n)\wedge\func{IsNew}(n)\right\}
       \cup\\&&\quad
       \left\{ \tuple{v, s} | v \in \func{def}(n)\wedge\func{IsMove}(n) \wedge
                              \exists u\in\func{use}(n) :
                                 \tuple{u,s}\in \func{In}_\text{Gs}(n)\right\}
\\
\func{Kill}_\text{Gs}(n) &=&
       \left\{ \tuple{v, s} | v \in \func{def}(n) \wedge
                         \tuple{v,s} \in \func{In}_\text{Gs}(n) \right\} %\\
\end{eqnarray*}
where
\begin{eqnarray*}
\func{IsMove}(n) &=& \text{true iff }n\text{ is a move statement } v=x\\
\func{IsNew}(n) &=& \text{true iff }n\text{ is a allocation statement } v=\text{\tt new }T\\
\func{IsBad}(n) &=& \neg\left(\func{IsMove}(n) \vee \func{IsNew}(n)\right) \\
\func{Ns}(v,n) &=&
%v\in\func{use}(n) \wedge \left(
\tuple{v,n} \in \func{In}_\text{Ru}(n) \vee
\exists n': \tuple{v,n'}\in\func{In}_\text{Nd}(n)
%\right)
\end{eqnarray*}
Note that $\func{IsBad}(n)$ is true for fetches from the heap and
definitions of formal parameters.  Note also that we treat allocation
and invocation of the constructor as two separate statements; the
$\func{IsNew}$ predicate is true only for allocation.

After the analysis is complete, $v$ is (conservatively) singular at
use $n$ if $\neg\func{Ns}(v,n)$.   We can use $\func{In}_\text{Gs}$ to
compute
$\func{GenSite}(\tuple{v,s})=\left\{ d | \tuple{v,d}\in\func{In}_\text{Gs}(s) \right\}$.

This analysis can be performed using a sparse representation, such as
SSA or SSI, as well.

Variable $v_1$ singular at $s_1$ is pairwise-singular to $v_2$
singular at $s_2$ if
\begin{displaymath}
\neg\exists 
     d : \tuple{v_1, d} \in \func{In}_\text{Gs}(s_1) \wedge
         \tuple{v_2, d} \in \func{In}_\text{Gs}(s_2) \wedge
\left(\func{Path}_{\mathcal{G}-d}(s_1, s_2) \vee
      \func{Path}_{\mathcal{G}-d}(s_2, s_1) \right)
\end{displaymath}

The mutual singularity of a group of static values can be computed
from the pairwise-singularity using the definitions in the previous
section.

\textbf{XXX: Perhaps present algorithm for determining mutual
singularity using a single graph traversal, keeping track of which
defs we've passed and halting when we hit another node without
having passed through a redef point?}

\subsection{Interprocedural singular value analysis}

We turn our intraprocedural singular value analysis into a compositional
interprocedural analysis by introducing ``conditional singularity''
for formal parameters and others which depend on them.  A
conditionally-singular variable is only singular if some set of actual
parameters is mutually-singular when the method is invoked.%
\footnote{Note that aliasing of parameters is one of the ways that
a set of parameters may fail to be mutually-singular.}
We let
$\func{CondParam}(\tuple{v,n})$ be the set of formal parameters which the
singularity of $v$ at $n$ is dependent on.  We can extend our dataflow
analysis of the previous section to compute this function.

Previously, the function $\func{In}_\text{Gs}$ was typed
$\mathcal{S\to V\times S}$
where $\mathcal{S}$ is the domain of statements
and $\mathcal{V}$ the domain of variables.
We expand that type to
$\mathcal{S\to V\times (S\cup P)}$ where $\mathcal{P}$ is a domain
representing formal parameters.  The set $P_m$ of formal parameters for
a method $m$ consists of unique tokens (possibly ordinal integers) for
each formal parameter of the method.  Let
$\func{formal}(p):\mathcal{P\to V}$ map parameter tokens to the
corresponding formal variables in a callee, and
$\func{actual}(p):\mathcal{P\to V}$ map parameter tokens to the
corresponding actual variables at a callsite.
Now, instead of initializing $\forall n :
\func{In}_\text{Gs}(n)=\emptyset$, we let
\begin{displaymath}
\func{In}_\text{Gs}(\text{\tt HEADER}) =
   \left\{ \tuple{v,p} | p\in P_m \wedge v=\func{formal}(p) \right\}
\end{displaymath}
We also extend the $\func{IsBad}$ predicate:
\begin{displaymath}
\func{IsBad}(n) = \neg\left(\func{IsMove}(n) \vee \func{IsNew}(n) \vee
                            n = \text{\tt HEADER} \right)
\end{displaymath}
so that definitions of formal parameters at the method entry header
are not marked as non-singular reaching definitions.  Now we can define
\begin{displaymath}
\func{CondParam}(\tuple{v,n}) =
    \left\{ p\in P_m | \tuple{v,p}\in \func{In}_\text{Gs}(n) \right\}
\end{displaymath}

A variable $v$ is singular at $n$ conditional on $P$ if
$P=\func{CondParam}(\tuple{v,n})$ and $\neg\func{Ns}(v,n)$.  This
is identical to our former case of non-conditional singularity
when $P=\emptyset$.  Variable $v_1$ singular at $s_1$ conditional on
$P_1$ is pairwise-singular conditional on $P_1\cup P_2$ to variable
$v_2$ singular at $s_2$ conditional on $P_2$ if
\begin{displaymath}
\neg\exists 
     d : \tuple{v_1, d} \in \func{In}_\text{Gs}(s_1) \wedge
         \tuple{v_2, d} \in \func{In}_\text{Gs}(s_2) \wedge
\left(\func{Path}_{\mathcal{G}-d}(s_1, s_2) \vee
      \func{Path}_{\mathcal{G}-d}(s_2, s_1) \right)
\end{displaymath}
as before, where $\mathcal{G}-d=\mathcal{G}$ if $d\notin\mathcal{S}$.

Similarly, a set of static values $\bigvar{SV}$ is
mutually-singular conditional on $P$ if
\begin{multline*}
\forall \left\{ \tuple{v_1,s_1}, \tuple{v_2,s_2} \right\} \subseteq
        \bigvar{SV} :
\hfill
v_1 \text{ singular at } s_1 \text{ conditional on } P_1
\mspace{-2mu}\quad\\\shoveright{{}\wedge
v_2 \text{ singular at } s_2 \text{ conditional on } P_2
}\\\shoveright{{}\wedge
v_1 \text{ at } s_1 \text{ on } P_1
\text{ is pairwise-singular with }
v_2 \text{ at } s_2 \text{ on } P_2
}\\{}\wedge
P_1 \cup P_2 \subseteq P
\end{multline*}

Now we can resolve conditional singularity compositionally by
examining actual parameters at a call-site $s_\text{call}\in S_\text{caller}$.
We let 
$\bigvar{SV}_\text{caller} \subseteq 
  V_\text{caller} \times S_\text{caller}$
be the set of static values in the caller, and
$\bigvar{SV}_\text{callee} \subseteq 
  V_\text{callee} \times S_\text{callee}$
be the set of static values in the callee.
A set $\bigvar{SV}=\bigvar{SV}_1 \cup \bigvar{SV}_2$ of static values,
where $\bigvar{SV}_1\subseteq \bigvar{SV}_\text{caller}$ and
      $\bigvar{SV}_2\subseteq \bigvar{SV}_\text{callee}$,
are mutually-singular conditional on $P$ if:
\begin{itemize}
\item $\bigvar{SV}_2$ are mutually-singular conditional on $P'$,
\item for all $\tuple{v_1,s_1}\in\bigvar{SV}_1$
there is no path from $s_1$ to $s_\text{call}$
             from $s_\text{call}$ to $s_1$,%
\footnote{Assuming METHOD\-ENTER in callee reaches all 
          $s\in S_\text{callee}$ and
          all $s\in S_\text{callee}$ reach METHOD\-EXIT in callee.}
and
\item all actual parameters corresponding to $P'$ at callsite $s_\text{call}$
  unioned with $\bigvar{SV}_1$ are mutually-singular conditional on $P$;
  that is, let
\begin{displaymath}
U = 
\left\{\tuple{\func{actual}(p), s_\text{call}} | p \in P' \right\}
    \cup
\bigvar{SV}_1
\end{displaymath}
then
\begin{multline*}
\forall \left\{\tuple{v_1,s_1},\tuple{v_2,s_2}\right\} \subseteq U :
\hfill
v_1 \text{ singular at } s_1 \text{ conditional on } P_1
\mspace{-2mu}\quad\\\shoveright{{}\wedge
v_2 \text{ singular at } s_2 \text{ conditional on } P_2
}\\\shoveright{{}\wedge
v_1 \text{ at } s_1 \text{ on } P_1
\text{ is pairwise-singular with }
v_2 \text{ at } s_2 \text{ on } P_2
}\\{}\wedge
P_1 \cup P_2 \subseteq P
\end{multline*}
\end{itemize}

So we can throw away all information internal to the callee except
mutually-singular sets of statements and their sets of dependent
formal parameters.

%A compositional
%analysis is presented to compute interprocedural singularity.
%This might be in some ways similar to interprocedural reaching defs?
%Computing mutual singularity can rest on the fact that values
%generated at sites inside a method can never be the same as values generated
%at sites outside the method; we don't have to compare site-by-site.

\section{Compositional Pointer Analysis}

\subsection{Overview}
Our compositional pointer analysis is loosely based on the Whaley/Rinard
escape and points-to framework.  We maintain additional
information sufficient to mark possible ``companion'' edges, and
extend the composition rules to maintain this information.
Unlike Whaley/Rinard, our analysis is flow-insensitive
and may be partially context-insensitive as well.  
We use the potential companion edges, in addition to escape information,
to determine whether to evaluate call-sites monomorphically or
polymorphically.
We also allow points-to solutions via Steensgaard-style unification as well as
the Anderson-style set constraints in the previous Whaley/Rinard
work.\footnote{Not yet.}

\begin{myfigure}
\begin{tabular}{ll|ll}
$l\in L$ & local variables           &$n\in N$ & nodes\\
$p\in P$ & formal parameter variables&$N_I\subseteq N$ & inside nodes\\
$v\in V=L\cup P$& all variables      &$N_T\subseteq N_I$ & thread nodes\\
$\bigvar{cl}\in \bigvar{CL}$& classes&$N_O\subseteq N$ & outside nodes\\
$m\in M$ & methods                   &$\bigvar{CL}\subseteq N$ 
                                                       & (static) class nodes\\
$f\in F$ & fields                    &$N_P\subseteq N_O$ & parameter nodes\\
$s\in S$ & statements                &$N_G\subseteq N_O$ & global nodes\\
         &                           &$N_L\subseteq N_O$ & load nodes\\
         &                           &$N_R\subseteq N_O$ & return nodes\\
\end{tabular}
\caption{Definitions}
\label{fig:defin}
\end{myfigure}

A points-to graph $\mathcal{G}_p$ is a quintuple of the form \tuple{O,I,\func{e},\func{c},r}, where
\begin{itemize}
\item $O \subseteq (N\times F)\times(N_L \cup N_G)$ is a set of
outside edges.  Outside edges represent references which may be
created outside the current analysis scope.%
\footnote{They may also (perhaps exclusively) alias to inside edges.}
\item $I \subseteq (V\cup(N\times F))\times N$ is a set of inside
edges.  Inside edges represent references created inside the current
analysis scope.
\item $\func{e}:N\to 2^M$ is an escape function that records the set of
unanalyzed method invocation sites that a node escapes down into.
\item $\func{c}:I\to 2^S$ collects store statements associated with
inside edges.  This allows us to detect possible companion edges.
\item $r \subseteq N$ is a return set representing the set of objects
that may be returned by the currently analyzed method.
\end{itemize}
We define:
\begin{eqnarray*}
\func{escaped}_\text{direct}(\tuple{O,I,\func{e},\func{c},r}, n) &=&
 n\in N_P \cup N_R \cup N_T \cup \bigvar{CL}
 \vee
 \func{e}(n)\neq\emptyset
%\\
%\func{escaped}_\text{v}(\tuple{O,I,\func{e},\func{c},r},v) &=&
% \exists n\in N : \tuple{v,n}\in I
% \wedge
% \func{escaped}_\text{n}(\tuple{O,I,\func{e},\func{c},r},n)
\end{eqnarray*}
and then recursively:
\begin{multline*}
\func{escaped}%_\text{n}
              (\tuple{O,I,\func{e},\func{c},r},n) =
 \func{escaped}_\text{direct}(\tuple{O,I,\func{e},\func{c},r},n) \vee {}
\\
 \exists n'\in N,f\in F : \left(\tuple{\tuple{n,f},n'}\in O\cup I
 \wedge
 \func{escaped}%_\text{n}
               (\tuple{O,I,\func{e},\func{c},r},n')\right)
\end{multline*}
% INVARIANT: a node n never *un*escapes during the (intraproc?) analysis.

We define the following auxilliary functions:
\begin{eqnarray*}
\func{condsing}(\bigvar{SV}):2^{V\times S}\to 2^P_\bot &=& \begin{cases}
P&\text{such that }\bigvar{SV}\text{ are mutually-singular conditional on }P \\
\bot & \text{if no such }P\text{ exists.}
\end{cases}
\\
\func{lhs}(s):S\to 2^{V\times S} &=& \begin{cases}
\left\{\tuple{v_1,s}\right\} &\text{if $s$ is \tt [v$_1$.f=v$_2$]}\\
\emptyset & \text{otherwise}
\end{cases}
\\
\func{rhs}(s):S\to 2^{V\times S} &=& \begin{cases}
\left\{\tuple{v_2,s}\right\} &\text{if $s$ is \tt [v$_1$.f=v$_2$]}\\
\emptyset & \text{otherwise}
\end{cases}
\end{eqnarray*}
Now we say that given \tuple{O,I,\func{e},\func{c},r},
an edge $e_i=\tuple{\tuple{n_1,f},n_2} \in I$ is a:
\begin{itemize}
\item \newterm{Definite companion} if:
\[
 n_1\in N_I \wedge n_2\in N_I \wedge
 \func{condsing}\left(U\right)=\emptyset \wedge
 \neg\func{escaped}(n_1)
\]
% XXX some redundancy here?
% note no outside edges to inside nodes.
% if n_1 escapes, then n_2 escapes.
% if only n_2 escapes, we can't create any new n_1.f=n_2 references
%   because we can't get to n_1
\item \newterm{Non-companion} if \(
 \func{condsing}(U) = \bot
\), and
\item \newterm{Possible companion} otherwise;
\end{itemize}
where 
$U=\bigcup_{s\in\func{c}(e_i)} \func{lhs}(s)$ for \newterm{from-companions} and
$U=\bigcup_{s\in\func{c}(e_i)} \func{rhs}(s)$) for \newterm{to-companions}.
We will say that an edge is a \newterm{companion edge} if it is a
definite or possible companion.

\subsection{Inference rules}
At the start of the analysis, we set $I=\emptyset$, $O=\emptyset$,
$\func{e}(n)=\emptyset$ for all $n\in N$, $\func{c}(i)=\emptyset$ for all $i\in I$,
and $r=\emptyset$.

\subsubsection{Static fields}

\begin{displaymath}
\dfrac{1\leq i \leq j}{\tuple{\tuple{\bigvar{cl}_i,f_i},n_{c_i.f_i}}\in O}
\end{displaymath}

\subsubsection{Method header}
Given method $m$ with formals $p_0,\ldots,p_k$:
\begin{displaymath}
\dfrac{0\leq i \leq k}{\tuple{p_i, n_{p_i}}\in I}
\end{displaymath}

\subsubsection{Copy statement}

\begin{displaymath}
\dfrac
{\text{\tt [l=v]}\in\mathcal{P} \wedge \tuple{v,n}\in I}
{\tuple{l,n}\in I}
\end{displaymath}

\textbf{Unify $l$ and $v$ for Steensgaard;  also the rule above is
  kept transitively closed; we actually want pre-transitive w/
  cycle-elimination for performance.}

\subsubsection{Load statement}

\begin{eqnarray*}
&
\dfrac
{\text{\tt [l$_1$=l$_2$.f]}\in\mathcal{P} \wedge
 \tuple{l_2,n}\in I \wedge
 \tuple{\tuple{n,f},n'}\in I}
{\tuple{l_1,n'}\in I}
\\&
\dfrac
{\text{\tt [l$_1$=l$_2$.f]}\in\mathcal{P} \wedge
 \tuple{l_2,n}\in I \wedge
 \func{escaped}(n) \wedge
 n' \text{ is load node for statement} }
{\tuple{l_1,n'}\in I \wedge \tuple{\tuple{n,f},n'}\in O}
\end{eqnarray*}

\subsubsection{Store statement}

\begin{displaymath}
\dfrac
{\text{\tt [l$_1$.f=l$_2$]}\in\mathcal{P} \wedge
 \tuple{l_1,n_1}\in I \wedge
 \tuple{l_2,n_2}\in I }
{\tuple{\tuple{n_1,f},n_2}\in I \wedge
 \text{\tt [l$_1$.f=l$_2$]}\in \func{c}(\tuple{\tuple{n_1,f},n_2}) }
\end{displaymath}

\textbf{More unification here??}

\subsubsection{Global load}

\begin{displaymath}
\dfrac
{\text{\tt [l=cl.f]}\in\mathcal{P} \wedge
 \tuple{\tuple{\bigvar{cl},f},n}\in (O\cup I) }
{\tuple{l,n}\in I}
\end{displaymath}

\subsubsection{Global store}

\begin{displaymath}
\dfrac
{\text{\tt [cl.f=l]}\in\mathcal{P} \wedge
 \tuple{l,n}\in I}
{\tuple{\tuple{\bigvar{cl},f},n}\in I}
\end{displaymath}

\subsubsection{Allocation}

\begin{displaymath}
\dfrac
{\text{\tt [l=new cl]}\in\mathcal{P} \wedge
 n \text{ is inside node for statement} }
{\tuple{l,n}\in I}
\end{displaymath}

\subsubsection{Method return}
% analogously; method throw.

\begin{displaymath}
\dfrac
{\text{\tt [return l]}\in\mathcal{P} \wedge
 \tuple{l,n}\in I}
{n\in r}
\end{displaymath}


\subsection{Evaluating a call-site monomorphically}

present rules.  don't need to say how we choose to eval
monomorphically yet.  Just keep the companion edges accurate.

\subsection{Evaluating a call-site polymorphically}

present rules.  don't need to say how we choose to eval
polymorphically yet.  Just keep the companion edges accurate,
keep updating mutual-singularity of field gets,
and rename internal nodes by call-site.

\section{Allocating Polymorphism}

We evaluate sites polymorphically if they are factory methods, or
contain unbalanced companion objects.  Otherwise, the site is
evaluated monomorphically.

(Roughly) If an allocated (internal?) node escapes via the return
value, then this is a factory method.  Evaluate it polymorphically.
If we have companion edges (including possible companions) from
an outside node to an inside node (or vice-versa?) --- that is, we
allocate a node internally which may be a companion of a node allocated
externally --- then evaluate it polymorphically.%
\footnote{Think hard about possible companion edges between an
outside and an outside node.  This could be, for example, a
link between two parameters of a method, both which would be
conditionally singular.  We should probably evaluate these
polymorphically, too?}
Otherwise, evaluate it monomorphically.

Possibly unify polymorphic allocation sites using a companion-based
naming system.  For example; A-pointed-to-by-B instead of
A-allocated-inside-foo().

\section{Related Work}

Bod{\'\i}k et al outlined a method for detecting infeasible paths
in \cite{267921} which could be used to extend the set of statements
we determine are mutually-singular (by enabling us to be less conservative).

Altucher et al renamed allocation sites for better alias analysis
precision on C programs with factory methods \cite{199466}.  They
do not handle Java or companion objects.

Collberg et al described a Java obfuscation technique that relies in
part on the intractability of alias analysis \cite{268962}.  The
analysis we describe is sufficient to break some of their predicates.
This could be used to construct a deobfuscator.  (These techniques
have been used in at least one commerical obfuscator \cite{humper02}.)


\bibliography{harpoon}
\end{document}
