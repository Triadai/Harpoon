% -*-latex-*- This is a LaTeX document.
% $Id: ptran.tex,v 1.17 2002-07-24 16:59:09 cananian Exp $
\documentclass[11pt,notitlepage]{article}
%\documentclass{acmconf}
\usepackage{comdef} % common definitions
\usepackage{pdffonts} % PDF-friendly fonts
\usepackage{stmaryrd} % for \rrbracket and \llbracket
\author{C.~Scott~Ananian}
\title{Points-To Analysis with Companion Objects}
\date{\today \\ $ $Revision: 1.17 $ $}

\begin{document}
\bibliographystyle{abbrv}
\maketitle
\section{Singular Values}

We say a program variable $v$ is \newterm{singular} at a statement $s$
if $v$ will have a different value at every execution of $s$.  An
allocation site \code{a = new A()} produces a value which is singular
at the site; other defintions of $a$ might reach other statements
$s_x$ in the program, so $a$ is not guaranteed to be singular at $s_x$.

A variable $v_1$ singular at a statement $s_1$ is
\newterm{pairwise-singular} with a variable $v_2$ singular at a statement
$s_2$ iff no value of $v_1$ at an execution $s_1$ is ever equal to any
value of $v_2$ at an execution of $s_2$.

Now we can say that a set $S$ of statements is
\newterm{mutually-singular} iff
\begin{displaymath}
%\begin{eqnarray}\lefteqn{
\forall s_1 \in S, s_2 \in S, v_1 \in \text{use}(s_1), v_2 \in \text{use}(s_2),
  s_1 \neq s_2 :
%} \\ & &
v_1 \text{ at } s_1 \text{ is pairwise-singular with } v_2 \text{ at } s_2
%\end{eqnarray}
\end{displaymath}

We can compute a conservative approximation to singularity as follows.
We say a variable $v$ is singular at a use $s$ iff:
\begin{itemize}
\item all reaching definitions of $v$ are either allocation statements 
$v = \text{new }T(\ldots)$ or moves $v = x$ where $x$ is singular at
the move, and
\item every non-trivial path from $s$ to $s$ redefines $v$.
\end{itemize}

Let $\text{Rd}(s,v)$ be the set of reaching definitions of $v$ at $s$.
We define the set of \newterm{generation sites} for a variable $v$ singular at
use $s$ as:
\begin{displaymath}
\text{GenSite}(s,v) %\text{ where } v\in\text{use}(s)
 =
\bigcup_{d \in \text{Rd}(s,v)} g(d)
\text{ where }
g(d) = \left\{ \begin{array}{cl}
                \text{GenSite}(d,x) &\text{when } d \text{ is } v=x \\
                \{d\}&\text{when } d \text{ is } v=\text{new } T(\ldots)
                \end{array}\right.
\end{displaymath}

We can then approximate pairwise-singularity by saying $v_1$ at $s_1$
is pairwise-singular with $v_2$ at $s_2$ if
\begin{displaymath}
\neg\exists d \in \text{GenSite}(s_1, v_1) \cap \text{GenSite}(s_2, v_2)
     : \text{Path}_{\mathcal{G}-d}(s_1, s_2) \vee
       \text{Path}_{\mathcal{G}-d}(s_2, s_1)
\end{displaymath}
where $\text{Path}_{\mathcal{G}-z}(x, y)$ is true iff there is a path
from $x$ to $y$ in directed control-flow graph $\mathcal{G}$ which
does not pass through $z$.
An infeasible path analysis \cite{267921} could be used to refine
this predicate by excluding paths never traversed by any
execution of the program.

\begin{myfigure}[p]
\begin{samplecode}[2]%
while (\ldots) \{         &while (\ldots) \{         \\
\>v = new T(\ldots)       &\>v1 = new T(\ldots)      \\
\>if (\ldots)             &\>if (\ldots)             \\
\>\>\ldots = v;  /* s1 */ &\>\>v2 = v1;              \\
\>else                    &\>if (\ldots)             \\
\>\>\ldots = v;  /* s2 */ &\>\>\ldots = v2;  /* s3 */ \\
\}                        &\>else                    \\
                          &\>\>\ldots = v2;  /* s4 */ \\
                          &\}                        \\
\end{samplecode}%
\caption{Statements $s_1$ and $s_2$ are pairwise-singular in the code
  on the left; statements $s_3$ and $s_4$ are not singular because
  there exist paths $s_3\pathplus s_3$ and $s_4\pathplus s_4$ which do not
  redefine \texttt{v2}.}
\label{fig:pairwise-singular}
\end{myfigure}

\subsection{Intraprocedural singular value analysis}

An intraprocedural analysis to compute $\text{GenSite}(s, v)$ and the
singularity of individual variables can be built using the standard
dataflow framework:
\begin{eqnarray*}
\text{Out}(n)&=&\left(\text{In}(n)-\text{Kill}(n)\right)\cup\text{Gen}(n) \\
\text{In}(n)&=&\bigcup_{p\in\text{pred}(n)} \text{Out}(p)\\
\end{eqnarray*}

We will perform the analysis simultaneously on three relations
$\text{Ru}$, $\text{Nd}$, and $\text{Gs}$.
The relations are represented as
sets of pairs \tuple{v, X} where
$\mathcal{R}(v)=X$ iff $\tuple{v,X} \in R$.
Both sets are initialized
to the empty set for all $n$, and grow monotonically as the analysis
progresses.
We let
$\text{Ru}(v)$ be the set of reaching \textbf{uses} of $v$ at $n$,
$\text{Nd}(v)$ be the set of \textbf{non-}singular reaching definitions
of $v$ at $n$,
 and
$\text{Gs}(v)$ be $\text{GenSite}(v,n)$, the set of generation sites
of $v$ at $n$.
The appropriate Gen and Kill rules are:
\begin{eqnarray*}
% this is the standard reaching-def rule:
%\text{Gen}_\text{Rd}(n) &=&
%       \left\{ \tuple{v, n} | v \in \text{def}(n) \right\} \\
%\text{Kill}_\text{Rd}(n) &=&
%       \left\{ \tuple{v, s} | v \in \text{def}(n) \wedge
%                          \tuple{v,s} \in \text{In}_\text{Rd}(n) \right\} \\
%%%%%%%%%%%%%%%%%%%%%%%%
\text{Gen}_\text{Ru}(n) &=&
        \left\{ \tuple{v, n} | v \in \text{use}(n) \right\} \\
\text{Kill}_\text{Ru}(n) &=&
        \left\{ \tuple{v, s} | v \in \text{def}(n) \wedge
                          \tuple{v,s} \in \text{In}_\text{Ru}(n) \right\} \\
%
% non-singular reaching defs of n.
\text{Gen}_\text{Nd}(n) &=&
        \left\{ \tuple{v, n} | v \in \text{def}(n) \wedge
\left( \text{IsBad}(n) \vee
\exists u\in\text{use}(n):\text{Ns}(u,n)
 \right) \right\}
\\
\text{Kill}_\text{Nd}(n) &=&
        \left\{ \tuple{v, s} | v \in \text{def}(n) \wedge
                          \tuple{v,s} \in \text{In}_\text{Nd}(n) \right\} \\
% gensites!
\text{Gen}_\text{Gs}(n) &=&
       \left\{ \tuple{v, n} | v \in \text{def}(n)\wedge\text{IsNew}(n)\right\}
       \cup\\&&\quad
       \left\{ \tuple{v, s} | v \in \text{def}(n)\wedge\text{IsMove}(n) \wedge
                              \exists u\in\text{use}(n) :
                                 \tuple{u,s}\in \text{In}_\text{Gs}(n)\right\}
\\
\text{Kill}_\text{Gs}(n) &=&
       \left\{ \tuple{v, s} | v \in \text{def}(n) \wedge
                         \tuple{v,s} \in \text{In}_\text{Gs}(n) \right\} \\
\end{eqnarray*}
where
\begin{eqnarray*}
\text{IsMove}(n) &=& \text{true iff }n\text{ is a move statement } v=x\\
\text{IsNew}(n) &=& \text{true iff }n\text{ is a allocation statement } v=\text{new }T(\ldots)\\
\text{IsBad}(n) &=& \neg\left(\text{IsMove}(n) \vee \text{IsNew}(n)\right) \\
\text{Ns}(v,n) &=&
%v\in\text{use}(n) \wedge \left(
\tuple{v,n} \in \text{In}_\text{Ru}(n) \vee
\exists n': \tuple{v,n'}\in\text{In}_\text{Nd}(n)
%\right)
\end{eqnarray*}
After the analysis is complete, $v$ is (conservatively) singular at
use $n$ if $\neg\text{Ns}(v,n)$, and 
$\text{GenSite}(s,v)=\left\{ d | \tuple{v,d}\in\text{In}_\text{Gs}(s) \right\}$.
Note that $\text{IsBad}(n)$ is true for fetches from the heap and
definitions of formal parameters.

This analysis can be performed using a sparse representation, such as
SSA or SSI, as well.

Statements $s_1$ and $s_2$ are pairwise-singular if
\begin{eqnarray*}
\neg\exists v_1\in\text{use}(s_1), v_2\in\text{use}(s_2),
     d &:& \tuple{v_1, d} \in \text{In}_\text{Gs}(s_1) \wedge
         \tuple{v_2, d} \in \text{In}_\text{Gs}(s_2) \wedge
\\&&\quad
\left(\text{Path}_{\mathcal{G}-d}(s_1, s_2) \vee
      \text{Path}_{\mathcal{G}-d}(s_2, s_1) \right)
\end{eqnarray*}

The mutual singularity of a group of statements can be computed from
the variable singularity and generation site information using the
definitions in the previous section.

\textbf{XXX: Perhaps present algorithm for determining mutual
singularity using a single graph traversal, keeping track of which
defs we've passed and halting when we hit another node without
having passed through a redef point?}

\subsection{Interprocedural singular value analysis}

We turn our intraprocedural analysis into a compositional
interprocedural analysis by introducing ``conditional singularity''
for formal parameters and others which depend on them.  A
conditionally-singular variable is singular if some set $P$ of formal
parameters is mutually singular at the call-site.  We extend
our dataflow analysis by introducing a new relation $\text{Cp}(v)$
representing the set of formal parameters which the singularity of $v$
at $n$ is dependent upon.  A variable $v$ at $n$ is
conditionally-singular if $\exists p:\tuple{v,p}\in\text{In}_\text{Cp}(n)$
and $\neg\text{Ns}(v,n)$.

(Roughly) We introduce ``conditional singularity'' for formal
parameters.  Other variables are ``conditionally singular'' if they
depend on the singularity of formal parameters.  A compositional
analysis is presented to compute interprocedural singularity.
This might be in some ways similar to interprocedural reaching defs?
Computing mutual singularity can rest on the fact that values
generated at sites inside a method can never be the same as values generated
at sites outside the method; we don't have to compare site-by-site.

\section{Compositional Pointer Analysis}

(Roughly) We use the Whaley/Rinard compositional pointer analysis
framework, except that we can mark edges as ``companion'' and
``possible companion''.  Annotate edges with the field set statements
used to create them.  If all field set statements associated with an
edge are mutually singular, then the edge is a companion ---
``possibly companion'' if some of the edges are outside edges (thus
we don't know if the field set statements associated with these edges
are going to be mutually singular with the rest).  ``Possibly
companion'' edges must still be mutually singular internally.

\subsection{Evaluating a call-site monomorphically}

present rules.  don't need to say how we choose to eval
monomorphically yet.  Just keep the companion edges accurate.

\subsection{Evaluating a call-site polymorphically}

present rules.  don't need to say how we choose to eval
polymorphically yet.  Just keep the companion edges accurate,
and rename internal nodes by call-site.

\section{Allocating Polymorphism}

We evaluate sites polymorphically if they are factory methods, or
contain unbalanced companion objects.  Otherwise, the site is
evaluated monomorphically.

(Roughly) If an allocated (internal?) node escapes via the return
value, then this is a factory method.  Evaluate it polymorphically.
If we have ``possible companion'' edges --- that is, we allocate
a node internally which may be a companion of a node allocated
externally --- then evaluate it polymorphically.  [I'm guessing
that possible companion edges which touch only outside, not inside,
nodes are not sufficient grounds for polymorphic evaluation.]
Otherwise, evaluate it monomorphically.

\section{Related Work}

Bod{\'\i}k et al outlined a method for detecting infeasible paths
in \cite{267921} which could be used to extend the set of statements
we determine are mutually singular (by enabling us to be less conservative).

Altucher et al renamed allocation sites for better alias analysis
precision on C programs with factory methods \cite{199466}.  They
do not handle Java or companion objects.

Collberg et al described a Java obfuscation technique that relies in
part on the intractability of alias analysis \cite{268962}.  The
analysis we describe is sufficient to break some of their predicates.
This could be used to construct a deobfuscator.  (These techniques
have been used in at least one commerical obfuscator \cite{humper02}.)


\bibliography{harpoon}
\end{document}
