% -*-latex-*- This is a LaTeX document.
% $Id: design.tex,v 1.3 1998-07-15 02:43:50 cananian Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[10pt,notitlepage,twocolumn]{article}
\author{C.~Scott~Ananian}
\title{Turning Java into Hardware: \\ Caffinated Compiler Construction}
\date{\today \\ $ $Revision: 1.3 $ $}

% PDF-friendly fonts:
\renewcommand{\rmdefault}{ptm}
\renewcommand{\sfdefault}{phv}
%\renewcommand{\ttdefault}{pcr}

% Outline:
% ~~~~~~~
% 0. Introduction. 
%    A. Why Java?
%       - simplicity, strong types, oo, threading
%       - BUT no bitwide types, no real time, no i/o grammar
%    B. Why hardware?
%       - codesign, etc.
% I. Java/Hardware semantics.
%    A. The rules.
%       1. Classes are objects.
%       2. Allocations are static.
%       3. Threads/Monitors model inherent parallelism.
%       4. Method calls form hardware interfaces.
%       5. Exceptions are?
%    B. A grammar for Java--.
%       (this is the implemented grammar, which might be more restrictive
%        than absolutely necessary. We might implement floating-point, more
%        powerful allocation analysis, etc, later).
%       1. No 'new' except in constructors.
%          (actually less draconian rule to guarantee A.2 above)
%       2. Floating-point is verboten.
%          (allowed, but not yet)
%       3. Throw and catch are not permitted? [we'll do them, but not yet]
%       4. Other features we don't care to implement?
%    C. An interface description language.
%       (more details on how methods map to chip pin-outs and timing)
%       1. Formal parameters map to chip ports.
%       2. Timing constraints on external events map to constraints on
%          class methods and executable code.
%       3. Syntax/Grammar/Examples.
% II. Useful analyses (compiler stages)
%    A. Static/Extended type analysis: not just type but which objs of the type
%    B. Static allocation.
%    C. Analyzing methods for side-effects.
%    D. Optimizations:
%       1. Common subexpression, constant-folding/propagation/subexpression
%       2. Partial Redundancy Elimination
%       3. Strength reduction (divide->multiply, multiple->add/rotate)
%       4. Exposing parallelism (removing control dependencies, loop analysis)
%       5. Bit-width analysis (combine with type analysis?)
%          - also, floating-point equivalent.
%    E. Representation Transformations
%       1. Java source -> bytecode (use javac for the foreseeable future)
%       2. Java bytecode -> quads (remove stack abstraction)
%       3. Quads -> SSA form? (best for optimizations?)
%       4. SSA -> dataflow?  (get rid of control dependencies, more opts?)
%       5. dataflow->logic functions (low-level hardware-(in)dependent stage)
%          (``logic function'' is some form of BDD?)
%       6. Logic function->Netlist (let others technology map, place and route)
% III. More details on hardware synthesis.
%    A. Dataflow/SSA to hardware
%       1. Branches become multiplexors. 
%          (control condition becomes selector bit)
%       2. State machines for iteration, recursion.
%       3. No memory stores. Value driven data flow.
%    B. Interface timing.
%       1. Computing 'go' signals from input timing constraints.
%       2. Synthesizing logic to adhere to an output timing constraint.
%    C. Object-orientation and inheritance.
%       1. Handling aliased classes and overloaded methods (type bits)
%       2. Parameterized classes (compile-time constructor evaluation)
% IV. Related Research (useful stuff from other people)
%    A. Various Intermediate Representations
%    B. Compiling Real-Time Programs
%    C. Array Analysis Techniques.
%    D. Loop analysis techniques.
%    E. Logic Synthesis (technology-independent timing, etc)
% V. Conclusion
%    Lots of work to keep me very busy for quite a while.

\begin{document}
\bibliographystyle{abbrv}
\maketitle

\section{Introduction}
blah blah blah blah

\section{Java/Hardware Semantics}
blah blah blah

\subsection{The rules}

\subsection{A Grammar for \textsc{Java--}}
\subsection{An interface description language}
\section{Compiler analyses}
\subsection{Static analysis} % Type, Allocation
\subsection{Functional Methods}
\subsection{Optimizations}
\subsection{Representations}
\section{Hardware Synthesis Details}
\subsection{Translating Dataflow/SSA into Hardware}
\subsection{Interface Timing Issues}
\subsection{Object-orientation and Inheritance}
\section{Related Research}
\subsection{Intermediate Representations}
\subsection{Compiling Real-Time programs}
\subsection{Array Analysis Techniques}
\subsection{Loop Analysis Techniques}
\subsection{Logic Synthesis}
\section{Conclusion}

\nocite{*}
\bibliography{harpoon}

\end{document}
