// Parser.cup, created Wed Feb 17 05:21:16 1999 by cananian
// Copyright (C) 1999 C. Scott Ananian <cananian@alumni.princeton.edu>
// Licensed under the terms of the GNU GPL; see COPYING for details.
package harpoon.Tools.PatMat;

import java_cup.runtime.*;

parser code {:
	Lexer lexer = null;
	ErrorMsg errorMsg;

	public void syntax_error(java_cup.runtime.Symbol current) {
	  report_error("Syntax error (" + current.sym + ")", current);
	}

	public void report_error(String message, 
			         java_cup.runtime.Symbol info) {
		errorMsg.error(info.left, message);
	}

	public Parser(Lexer l, ErrorMsg err) {
	  this();
	  lexer = l;
	  errorMsg=err;
	}
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, GLOBAL_STATEMENTS, CLASS_STATEMENTS, BRACED, PARENED;
terminal Integer NUMBER;
// %keys
terminal KEY_EXTRA, KEY_WEIGHT, KEY_PRED;
// tree nodes
terminal BINOP, CALL, CJUMP, CONST, ESEQ, EXP, JUMP, LABEL;
terminal MEM, MOVE, NAME, NATIVECALL, RETURN, SEQ, TEMP, THROW;
terminal UNOP;
// punctuation & brackets
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, LANGLE, RANGLE;
terminal COMMA, EQUALS;
// binops
terminal ADD, AND, CMPEQ, CMPGE, CMPGT, CMPLE, CMPLT, DIV, MUL, OR;
terminal REM, SHL, SHR, USHR, XOR;
// unops
terminal _2B, _2C, _2D, _2F, _2I, _2L, _2S, NEG, NOT;

non terminal program, ruleSeq, rule;
non terminal exp, stm, detailSeq, detail, idList, types;
non terminal opt_idList, opt_types;
non terminal binops, unops, sym_binops, sym_unops, sym_number;

start with program;

program	::=	GLOBAL_STATEMENTS CLASS_STATEMENTS ruleSeq
	;

ruleSeq	::=	/* empty */
	|	rule ruleSeq
	;

rule	::=	exp EQUALS ID detailSeq BRACED
	|	stm detailSeq BRACED
	;

detailSeq ::=	/* empty */
	|	detail detailSeq
	;

detail	::=	KEY_EXTRA LBRACE opt_idList RBRACE
	|	KEY_PRED PARENED
	|	KEY_WEIGHT LANGLE ID COMMA NUMBER RANGLE
	;

opt_idList ::=	/* empty */
	|	idList
	;

idList	::=	ID
	|	idList COMMA ID
	;


exp	::=	ID
	|	BINOP opt_types LPAREN sym_binops COMMA exp COMMA exp RPAREN
	|	CONST opt_types LPAREN sym_number RPAREN
	|	ESEQ LPAREN stm COMMA exp RPAREN
	|	MEM opt_types LPAREN exp RPAREN
	|	NAME LPAREN ID RPAREN
	|	TEMP opt_types LPAREN ID RPAREN
	|	UNOP opt_types LPAREN sym_unops COMMA exp RPAREN
	;

stm	::=	CALL LPAREN exp COMMA exp COMMA exp COMMA ID RPAREN
	|	CJUMP LPAREN exp COMMA ID COMMA ID RPAREN
	|	EXP LPAREN exp RPAREN
	|	JUMP LPAREN exp RPAREN
	|	LABEL LPAREN ID RPAREN
	|	MOVE LPAREN exp COMMA exp RPAREN
	|	NATIVECALL LPAREN exp COMMA exp COMMA exp COMMA ID RPAREN
	|	RETURN opt_types LPAREN exp RPAREN
	|	SEQ LPAREN stm COMMA stm RPAREN
	|	THROW LPAREN exp RPAREN
	;

opt_types ::=	/* nothing */
	|	types
	;

types	::=	LANGLE opt_idList RANGLE
	;

sym_number ::=	ID
	|	NUMBER
	;
sym_binops ::=	ID
	|	binops
	;
sym_unops ::=	ID
	|	unops
	;

binops	::=	ADD
	|	AND
	|	CMPEQ
	|	CMPGE
	|	CMPGT
	|	CMPLE
	|	CMPLT
	|	DIV
	|	MUL
	|	OR
	|	REM
	|	SHL
	|	SHR
	|	USHR
	|	XOR
	;

unops	::=	_2B
	|	_2C
	|	_2D
	|	_2F
	|	_2I
	|	_2L
	|	_2S
	|	NEG
	|	NOT
	;
