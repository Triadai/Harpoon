// AsyncCode.java, created Thu Nov 11 15:17:54 1999 by kkz
// Copyright (C) 1999 Karen K. Zee <kkzee@alum.mit.edu>
// Licensed under the terms of the GNU GPL; see COPYING for details.
package harpoon.Analysis.EventDriven;

import harpoon.Analysis.ContBuilder.ContBuilder;
import harpoon.Analysis.EnvBuilder.EnvBuilder;
import harpoon.Analysis.Quads.QuadLiveness;
import harpoon.Analysis.Quads.Unreachable;
import harpoon.ClassFile.HClass;
import harpoon.ClassFile.HClassSyn;
import harpoon.ClassFile.HCode;
import harpoon.ClassFile.HConstructor;
import harpoon.ClassFile.HMethod;
import harpoon.ClassFile.HMethodSyn;
import harpoon.ClassFile.UpdateCodeFactory;
import harpoon.IR.Quads.CALL;
import harpoon.IR.Quads.Code;
import harpoon.IR.Quads.Edge;
import harpoon.IR.Quads.FOOTER;
import harpoon.IR.Quads.HEADER;
import harpoon.IR.Quads.NEW;
import harpoon.IR.Quads.PHI;
import harpoon.IR.Quads.Quad;
import harpoon.IR.Quads.QuadNoSSA;
import harpoon.IR.Quads.RETURN;
import harpoon.IR.Quads.THROW;
import harpoon.Temp.Temp;
import harpoon.Temp.TempFactory;
import harpoon.Util.Util;
import harpoon.Util.WorkSet;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * <code>AsyncCode</code>
 * 
 * @author Karen K. Zee <kkzee@alum.mit.edu>
 * @version $Id: AsyncCode.new,v 1.1.2.1 1999-12-16 22:49:29 kkz Exp $
 */
public class AsyncCode extends harpoon.IR.Quads.QuadNoSSA {

    /** Creates a <code>AsyncCode</code>. 
     *
     *  @param parent
     *         the <code>HMethod</code> to which this <code>AsyncCode</code>
     *         belongs.
     *  @param hc
     *         the <code>HCode</code> from which to build this
     *         <code>AsyncCode</code>.
     *  @param bcs
     *         maps blocking call sites (<code>Quad</code>s) to the 
     *         replacement <code>HMethod</code>.
     *  @param liveness
     *         results of liveness analysis
     *  @param swop
     *         a <code>Set</code> of <code>CALL</code>s to 
     *         java.net.Socket.getInputStream, which will be replaced with
     *         <code>CALL</code>s to java.net.Socket.getAsyncInputStream
     *  @param ucf
     *         <code>UpdateCodeFactory</code> with which to register new
     *         <code>HCode</code>
     */
    public AsyncCode(HMethod parent, HCode hc, Map bcs, QuadLiveness liveness,
		     Set swop, UpdateCodeFactory ucf) 
	throws NoClassDefFoundError
    {
	super(parent, null);
	this.quads = buildCode(hc, bcs, liveness, swop, ucf);
    }

    private AsyncCode(HMethod parent) {
	super(parent, null);
    }

    /** Clone this code representation.  The clone has its own copy of
     *  the quad graph. 
     */
    public HCode clone(HMethod newMethod) {
	AsyncCode ac = new AsyncCode(newMethod);
	ac.quads = Quad.clone(ac.qf, this.quads);
	return ac;
    }

    /**
     * Return the name of this code view.
     * @return the name of the <code>parent</code>'s code view.
     */
    public String getName() {
	return harpoon.IR.Quads.QuadNoSSA.codename;
    }

    private Quad buildCode(HCode hc, Map bcs, QuadLiveness liveness,
			   Set swop, UpdateCodeFactory ucf) 
	throws NoClassDefFoundError
    {
	System.out.println("Entering AsyncCode.buildCode()");

	Quad root = (Quad)hc.getRootElement();
	Object[] maps = Quad.cloneMaps(this.qf, root);
	Map quadmap = (Map)maps[0];
	TempFactory tf = this.qf.tempFactory();

	System.out.println("AsyncCode.buildCode(): Initialization done!");

	// swop out all the calls to Socket.getInputStream and 
	// replace with calls to Socket.getAsyncInputStream:
	swop(swop, quadmap);
       
	System.out.println("AsyncCode.buildCode(): getInputStream swopped!");
	System.out.println("AsyncCode.buildCode(): Handling CALLs...");
	WorkSet needHandler=new WorkSet();
	WorkSet needContCode = new WorkSet();
	WorkSet needAsyncCode = new WorkSet();
	for (Iterator i = bcs.keySet().iterator(); i.hasNext(); ) {
	    System.out.print(".");
	    CALL c = (CALL)i.next();        // original CALL (blocking)
	    CALL cc = (CALL)quadmap.get(c); // cloned CALL (to be non-blocking)

	    // we want to remove this cloned CALL and replace it
	    // with a call to the asynchronous version of the method
	    HMethod replacement = (HMethod)bcs.get(c);
	    if (replacement == null) {
		// if we don't have already have a 
		// replacement, we need to build one
		replacement = makeAsync(bcs, c, ucf);
		bcs.put(c, replacement);
		// not sure when we actually build the HCode for this...
		needAsyncCode.add(replacement);
	    }

	    Temp async = new Temp(tf);
	    Temp exc = new Temp(tf);

	    CALL nc = new CALL(this.qf, cc, replacement, cc.params(), 
			       async, exc, true, false, new Temp[0]);
	    needHandler.add(nc);

	    // hook up all incoming edges
	    Edge[] e = cc.prevEdge();
	    for (int j=0; j<e.length; j++) {
		Quad.addEdge((Quad)e[j].from(), e[j].which_succ(), 
			     nc, e[j].which_pred());
	    }
	    Quad prev = nc;
	    Quad curr = null;

	    System.out.println("AsyncCode.buildCode(): replaced call");

	    // build environment class
	    Temp[] liveout = liveness.getLiveOutArray(c);
	    EnvBuilder eb = new EnvBuilder(ucf, hc, c, liveout);
	    HClass env = eb.makeEnv();

	    // create new environment
	    Temp newenv = new Temp(tf);
	    curr = new NEW(this.qf, cc, newenv, env);
	    Quad.addEdge(prev, 0, curr, 0);
	    prev = curr;

	    // create params (need to add receiver object)
	    Temp[] params = new Temp[liveout.length+1];
	    params[0] = newenv;
	    for (int j=0;j<liveout.length;j++) {
		params[j+1]=liveout[j];
	    }

	    // call constructor
	    Util.assert(env.getConstructors().length == 1,
			"AsyncCode.buildCode(): " + 
			env.getConstructors().length +
			" constructor(s) found for environment.");
	    
	    // since this is a call to the constructor, 
	    // we mark it as not virtual
	    curr = new CALL(this.qf, cc, env.getConstructors()[0], 
			    params, null, exc, false, 
			    false, new Temp[0]);
	    needHandler.add(curr);

	    Quad.addEdge(prev, 0, curr, 0);
	    prev = curr;

	    System.out.println("AsyncCode.buildCode(): Done w/ Environment");

	    // create the continuation HClass
	    final HClass cont = createContinuation(this.parent, c, ucf);
	    // don't know when we're going to add code for the resume method...
	    needContCode.add(cont);

	    // create new continuation
	    Temp newcont = new Temp(tf);
	    curr = new NEW(this.qf, cc, newcont, cont);
	    Quad.addEdge(prev, 0, curr, 0);
	    prev = curr;

	    // call constructor
	    Util.assert(cont.getConstructors().length == 1,
			"AsyncCode.buildCode(): " + 
			cont.getConstructors().length +
			" constructor(s) found for continuation.");

	    // kkz: haven't yet looked at what's going on w/ below this line
	    // -------------------------------------------------------------

	    /*
	    // call to constructor is not virtual
	    // BCD needs exception handler...
	    curr = new CALL(this.qf, cc, cont.getConstructors()[0],
			    new Temp[] {newcont, newenv}, null, exc,
			    false, false, new Temp[0]);
	    needHandler.add(curr);
	    Quad.addEdge(prev, 0, curr, 0);
	    prev = curr;

	    System.out.println("Attempting Access to " +
			       toCall.getReturnType() + " " + cont);

	    //BCD start
	    HClass[] interfaces=cont.getInterfaces();
	    for (int cci=0;cci<interfaces.length;cci++)
		System.out.println("implements " + interfaces[cci]);
	    //BCD stop
	    if (cont.getSuperclass()!=null)
		System.out.println("super "+cont.getSuperclass());
	    
	    // setNext(<continuation>);
	    
	    HMethod setnextmethod=null;
	    HMethod[] allMethods=toCall.getReturnType().getMethods();
	    for(int sMethod=0;sMethod<allMethods.length;sMethod++)
		if (allMethods[sMethod].getName().compareTo("setNext")==0)
		    //We found a possible method
		    if (allMethods[sMethod].getParameterTypes().length==1) {
			HClass param1 =
			    allMethods[sMethod].getParameterTypes()[0];
			if (param1.isAssignableFrom(cont)) {
			    setnextmethod=allMethods[sMethod];
			    break;
			}
		    }
	    Util.assert(setnextmethod!=null,"no setNext method found");

	    //HMethod setnextmethod = 
	    //    toCall.getReturnType().getMethod("setNext", 
	    //				     new HClass[] {cont});
	    // this is a tail call, but that's not supported yet,
	    // so we mark it as not a tail call.
	    curr = new CALL(this.qf, cc, setnextmethod, 
			    new Temp[] {async, newcont}, null, 
			    exc, true, false, new Temp[0]);
	    needHandler.add(curr);
	    Quad.addEdge(prev, 0, curr, 0);
	    prev = curr;
	
	    // return(<continuation>);
	    curr = new RETURN(this.qf, cc, newcont);
	    Quad.addEdge(prev, 0, curr, 0);
	    prev = curr;

	    System.out.println("AsyncCode.buildCode() 9");
	    
	    // Build THROW/PHI's
	    PHI phi = new PHI(this.qf, curr, new Temp[0], needHandler.size());
	    int phiedge=0;
	    for(Iterator callIterator=needHandler.iterator();
		callIterator.hasNext();)
		Quad.addEdge((Quad)callIterator.next(),1, phi, phiedge++);
	    THROW throwq=new THROW(this.qf, curr, exc);
	    Quad.addEdge(phi,0,throwq,0);
	    
	    // find FOOTER
	    HEADER header = (HEADER) hc.getRootElement();
	    FOOTER q = (FOOTER) header.next(0);
	    
	    FOOTER f = (FOOTER)quadmap.get(q); // cloned FOOTER
	    FOOTER newf = f.attach(prev,0);
	    newf=newf.attach(throwq,0);
	    
	    //Note that quadmap is now invalid for the footer...
	    //But it doesn't escape
	    */
	}
	
	HEADER h = (HEADER)quadmap.get(root); // get cloned HEADER
	Unreachable.prune(h);
	System.out.println("Leaving AsyncCode.buildCode()");
	return h;
    }

    // swop out all the calls to Socket.getInputStream and 
    // replace with calls to Socket.getAsyncInputStream:
    private void swop(Set s, Map quadmap) {
	final HMethod gais = 
	    HClass.forName("java.net.Socket").getDeclaredMethod
	    ("getAsyncInputStream", new HClass[0]);
	for (Iterator i=s.iterator(); i.hasNext(); ) {
	    CALL cts = (CALL)quadmap.get(i.next()); // call to swop
	    CALL replacement = new CALL(this.qf, cts, gais, cts.params(),
					cts.retval(), cts.retex(), 
					cts.isVirtual(), cts.isTailCall(),
					new Temp[0]);
	    // hook up all incoming edges
	    Edge[] pe = cts.prevEdge();
	    for (int j=0; j<pe.length; j++) {
		Quad.addEdge((Quad)pe[j].from(), pe[j].which_succ(), 
			     replacement, pe[j].which_pred());
	    }

	    // hook up outgoing edges
	    Edge[] ne = cts.nextEdge();
	    for (int j=0; j<ne.length; j++) {
		Quad.addEdge(replacement, ne[j].which_succ(),
			     (Quad)ne[j].to(), ne[j].which_pred());
	    }
	}
	
    }

    // create asynchronous version of HMethod to replace blocking version
    // does not create HCode that goes w/ it...
    private HMethod makeAsync(Map blocking2async, CALL blocking,
			      UpdateCodeFactory ucf)
    {
	final HMethod original = blocking.method();
	final HClass originalClass = original.getDeclaringClass();

	// create a new HClassSyn that replaces the original HClass
	final HClassSyn replacementClass = new HClassSyn(originalClass, true);

	// clone HMethods from original class
	HMethod[] toClone = originalClass.getDeclaredMethods();
	for (int i = 0; i < toClone.length; i++) {
	    HMethod clone = replacementClass.getDeclaredMethod
		(toClone[i].getName(), toClone[i].getParameterTypes());
	    ucf.update(clone, 
		       ((QuadNoSSA)ucf.convert(toClone[i])).clone(clone));
	}
	
	// use the return type of the original HMethod to get the String 
	// prefix for the type of Continuation we want as the new return type
	final String pref = ContBuilder.getPrefix(original.getReturnType());

	// get the return type for the replacement HMethod
	final HClass newReturnType = HClass.forName
	    ("harpoon.Analysis.ContBuilder" + pref + "Continuation");

	// find a unique name for the replacement HMethod
	final String methodNamePrefix = original.getName() + "Async_";
	String newMethodName = methodNamePrefix;
	int i = 0;
	while(true) {
	    try {
		newMethodName = methodNamePrefix + i++; 
		replacementClass.getMethod(newMethodName, 
					   original.getParameterTypes());
	    } catch (NoSuchMethodError e) {
		break;
	    }
	}
	
	// create replacement method
	final HMethodSyn replacement = 
	    new HMethodSyn(replacementClass, newMethodName, 
			   original.getParameterTypes(), newReturnType);

	replacement.setExceptionTypes(original.getExceptionTypes());
	replacement.setModifiers(original.getModifiers());
	replacement.setParameterNames(original.getParameterNames());
	replacement.setSynthetic(original.isSynthetic());

	return replacement;
    }

    // creates the HClass and constructor for the continuation
    private HClass createContinuation(HMethod blocking, CALL callsite,
				      UpdateCodeFactory ucf) 
	throws NoClassDefFoundError
    {
	final HClass template = 
	    HClass.forName("harpoon.Analysis.ContBuilder.ContTemplate");

	final HClassSyn continuationClass = new HClassSyn(template);
	final int numConstructors = continuationClass.getConstructors().length;
	Util.assert(numConstructors == 1,
		    "Found " + numConstructors + " constructors in " +
		    "ContTemplate. Expected one");

	// use the return type of the blocking HMethod to get the String 
	// prefix for the superclass for the continuation we want to create
	final String superPref = 
	    ContBuilder.getPrefix(blocking.getReturnType());

	// get the superclass for the continuation
	final HClass superclass = HClass.forName
	    ("harpoon.Analysis.ContBuilder." + superPref + "Continuation");

	continuationClass.setSuperclass(superclass);

	// we want the return type of the blocking call
	// this gives us the interface that our continuation should implement
	final String interPref = 
	    ContBuilder.getPrefix(callsite.method().getReturnType());

	// get the interface that the continuation needs to implement
	final HClass inter = HClass.forName("harpoon.Analysis.ContBuilder." + 
					    interPref + "ResultContinuation");
	
	final HClass environment = HClass.forName
	    ("harpoon.Analysis.EnvBuilder.Environment");

	// clone template's constructor HCode
	HConstructor hc = null;
	HConstructor nhc = null;
	try {
	    hc = template.getConstructor(new HClass[] {environment});
	    nhc = continuationClass.getConstructor(new HClass[] {environment});
	    HCode hchc = ((Code)ucf.convert(hc)).clone(nhc);
	    ucf.update(nhc, hchc);
	} catch (NoSuchMethodError e) {
	    System.err.println("Missing constructor for environment template");
	}

	// create resume method but HCode not yet created
	HMethod hm = null;
	HMethodSyn nhm = null;
	try {
	    hm = continuationClass.getDeclaredMethod("resume", new HClass[0]);
	    nhm = new HMethodSyn(continuationClass, hm, true);
	    continuationClass.removeDeclaredMethod(hm);
	} catch (NoSuchMethodError e) {
	    System.err.println("Missing resume() from constructor template");
	}

	// get the return value of the blocking call
	// this is the parameter of the resume method, if any
	HClass rettype = callsite.method().getReturnType();
	Temp retval = callsite.retval();
	boolean hasParameter = false;
	if (retval != null) {
	    hasParameter = true;
	    String[] parameterNames = new String[1];
	    parameterNames[0] = retval.name();
	    HClass[] parameterTypes = new HClass[1];
	    if (rettype.isPrimitive())
		parameterTypes[0] = rettype;
	    else {
		parameterTypes[0] = HClass.forName("java.lang.Object");
	    }
	    nhm.setParameterNames(parameterNames);
	    nhm.setParameterTypes(parameterTypes);
	}

	return continuationClass;
    }
}
