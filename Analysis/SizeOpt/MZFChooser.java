// MZFChooser.java, created Mon Nov 12 22:20:58 2001 by cananian
// Copyright (C) 2000 C. Scott Ananian <cananian@alumni.princeton.edu>
// Licensed under the terms of the GNU GPL; see COPYING for details.
package harpoon.Analysis.SizeOpt;

import harpoon.Analysis.Transformation.*;
import harpoon.ClassFile.*;
import harpoon.IR.Quads.*;
import harpoon.Temp.*;
import harpoon.Util.Collections.*;
import harpoon.Util.*;

import java.lang.reflect.*;
import java.util.*;
/**
 * <code>MZFChooser</code> adds code to instantiate the correct
 * MZF-compressed version of a class at run-time.
 * 
 * @author  C. Scott Ananian <cananian@alumni.princeton.edu>
 * @version $Id: MZFChooser.java,v 1.1.2.1 2001-11-13 05:32:33 cananian Exp $
 */
class MZFChooser extends MethodMutator {
    /** an oracle to determine the properties of constructors. */
    final ConstructorClassifier cc;
    /** a map from HClasses to a list of sorted fields; the splitting has
     *  been done in the order of the list. */
    final Map listmap;
    /** a map from <code>HField</code>s to the <code>HClass</code> which
     *  eliminates that field. */
    final Map field2class;
    /** Creates a <code>MZFChooser</code>. */
    public MZFChooser(HCodeFactory hcf, ConstructorClassifier cc,
		      Map listmap, Map field2class) {
        super(QuadSSA.codeFactory(hcf));
	this.cc = cc;
	this.listmap = listmap;
	this.field2class = field2class;
    }
    protected HCode mutateHCode(HCodeAndMaps input) {
	HCode hc = input.hcode();
	// first, find set of constructor-calls in this HCode.
	QuadFinder qfinder = new QuadFinder();
	for (Iterator it=hc.getElementsI(); it.hasNext(); )
	    ((Quad)it.next()).accept(qfinder);
	// for each constructor:
	for (Iterator it=qfinder.constructors.iterator(); it.hasNext(); ) {
	    CALL qC = (CALL) it.next();
	    Util.assert(!qC.isVirtual());
	    // match it to a 'NEW'.
	    NEW qN = (NEW) qfinder.temp2new.get(qC.params(0));
	    if (qN==null) continue; // typically call to super-constructor.
	    // if we know anything about this constructor...
	    if (!cc.isGood(qC.method())) continue;
	    Util.assert(qN.hclass().equals(qC.method().getDeclaringClass()),
			qN+" / "+qC);
	    // fetch field list for this class.
	    List sortedFields = (List) listmap.get(qN.hclass());
	    if (sortedFields==null) continue; // nothing known about this class
	    if (true) {
		System.err.println("can optimize call to "+qC.method());
		continue;
	    }
	    // delete the NEW.
	    qN.remove();
	    // replace CALL with test-and-NEW-and-CALL.
	    refactor(qC.method(), qC, sortedFields);
	}
	return hc;
    }
    static class QuadFinder extends QuadVisitor {
	/** map temps to 'NEW's where they are defined. */
	Map temp2new = new HashMap();
	/** set of constructor CALLs. */
	Set constructors = new HashSet();
	public void visit(Quad q) { /* not interesting */ }
	public void visit(NEW q) {
	    Util.assert(!temp2new.containsKey(q.dst()), "SSx form");
	    temp2new.put(q.dst(), q);
	}
	public void visit(CALL q) {
	    if (isConstructor(q.method()))
		constructors.add(q);
	}
	///////// copied from harpoon.Analysis.Quads.DefiniteInitOracle.
	/** return an approximation to whether this is a constructor
	 *  or not.  it's always safe to return false. */
	private static boolean isConstructor(HMethod hm) {
	    // this is tricky, because we want split constructors to
	    // count, too, even though renamed constructors (such as
	    // generated by initcheck, for instance) won't always be
	    // instanceof HConstructor.  Look for names starting with
	    // '<init>', as well.
	    if (hm instanceof HConstructor) return true;
	    if (hm.getName().startsWith("<init>")) return true;
	    // XXX: what about methods generated by RuntimeMethod Cloner?
	    // we could try methods ending with <init>, but then the
	    // declaringclass information would be wrong.
	    //if (hm.getName().endsWidth("<init>")) return true;//not safe yet.
	    return false;
	}
    }
    void refactor(HMethod constructor, CALL qC, List sortedFields) {
	if (sortedFields.size()==0) { // base case.
	    Quad qN = new NEW(qC.getFactory(), qC, qC.params(0),
			      qC.method().getDeclaringClass());
	    addAt(qC.prevEdge(0), qN);
	    return;
	}
	List pair = (List) sortedFields.get(0);
	HField hf = (HField) pair.get(0); // field
	Number num = (Number) pair.get(1); // 'mostly-what?'
	// check whether this field is constant w/ this constructor.
	if (cc.isConstant(constructor, hf)) {
	    Object val = cc.constantValue(constructor, hf);
	    if (val==null ? num.longValue()==0 :
		((Number)val).doubleValue()==num.doubleValue()) {
		// okay, always a constant of the right value.
		// we can replace original constructor with alternate.
		HClass newC = (HClass) field2class.get(hf);
		HMethod newM = newC.getDeclaredMethod
		    (constructor.getName(), constructor.getDescriptor());
		CALL qCN = new CALL(qC.getFactory(), qC, newM,
				    qC.params(), qC.retval(), qC.retex(),
				    qC.isVirtual(), qC.isTailCall(),
				    qC.dst(), qC.src());
		Quad.replace(qC, qCN);
		// now recursively invoke on rest of list.
		refactor(constructor, qCN,
			 sortedFields.subList(1, sortedFields.size()));
		return;
	    }
	}
	// check whether this field is a function of a param.
	if (cc.isParam(constructor, hf)) {
	    int which = cc.paramNumber(constructor, hf);
	    // XXX test whether param(which) is equal to 'num'.
	    // if so, use specialized class, else fall back.
	    System.err.println("COULD FURTHER SPECIALIZE "+constructor+" FOR "+hf);
	}
	// nothing known about this field w/ this constructor.
	// clean up (add NEW) and go home.
	Quad qN = new NEW(qC.getFactory(), qC, qC.params(0),
			  qC.method().getDeclaringClass());
	addAt(qC.prevEdge(0), qN);
	return;
    }
    // private helper functions.
    private static Edge addAt(Edge e, Quad q) { return addAt(e, 0, q, 0); }
    private static Edge addAt(Edge e, int which_pred, Quad q, int which_succ) {
	Quad frm = (Quad) e.from(); int frm_succ = e.which_succ();
	Quad to  = (Quad) e.to();   int to_pred = e.which_pred();
	Quad.addEdge(frm, frm_succ, q, which_pred);
	Quad.addEdge(q, which_succ, to, to_pred);
	return to.prevEdge(to_pred);
    }
}
