// ConstructorClassifier.java, created Thu Nov  8 19:38:41 2001 by cananian
// Copyright (C) 2000 C. Scott Ananian <cananian@alumni.princeton.edu>
// Licensed under the terms of the GNU GPL; see COPYING for details.
package harpoon.Analysis.SizeOpt;

import harpoon.Analysis.ClassHierarchy;
import harpoon.Analysis.Quads.*;
import harpoon.ClassFile.*;
import harpoon.IR.Quads.*;
import harpoon.Util.*;

import java.util.*;
/**
 * The <code>ConstructorClassifier</code> class takes a look at
 * constructor invocations and determines whether we can do one
 * of several 'mostly-zero field' transformations.
 * 
 * @author  C. Scott Ananian <cananian@alumni.princeton.edu>
 * @version $Id: ConstructorClassifier.java,v 1.1.2.1 2001-11-09 01:40:07 cananian Exp $
 */
public class ConstructorClassifier {
    /* Definitions:
     * - a 'this-final' field is only written in constructors of its type.
     *   it is not written in subclass constructors.  every write within
     *   its constructor *must* be to the 'this' object.
     * - a 'subclass-final' field is only written in constructors of its type
     *   *and methods of subclasses*.  Every write in its own constructors
     *   must be to the 'this' object as before.
     *
     * classes with 'subclass' final fields can be split into a 'small'
     * version without the field, which is the superclass of a 'large' version
     * with the field (and a setter method).  Subclasses of the original
     * class extend the 'large' version and so can write the extra field.
     */

    
    /** Creates a <code>ConstructorClassifier</code>. */
    public ConstructorClassifier(HCodeFactory hcf, ClassHierarchy ch,
				 FieldSyncOracle fso) {
        // first, find all the 'subclass-final' fields in the program.
	// actually, we find the dual of this set.
	Set badFields = findBadFields(hcf, ch);
	// debug:
	System.out.println("BAD FIELDS: "+badFields);
    }
    Set findBadFields(HCodeFactory hcf, ClassHierarchy ch) {
	Set badFields = new HashSet();
	// for each callable method...
	for (Iterator it=ch.callableMethods().iterator(); it.hasNext(); ) {
	    HMethod hm = (HMethod) it.next();
	    HCode hc = hcf.convert(hm);
	    if (hc==null) continue; // xxx: native methods may write fields!
	    // construct a must-param oracle for constructors.
	    MustParamOracle mpo = 
		isConstructor(hm) ? new MustParamOracle(hc) : null;
	    // examine this method for writes
	    HClass thisClass = hc.getMethod().getDeclaringClass();
	    for (Iterator it2=hc.getElementsI(); it2.hasNext(); ) {
		Quad q = (Quad) it2.next();
		if (q instanceof SET) {
		    SET qq = (SET) q;
		    // ignore writes of static fields.
		    if (qq.isStatic()) continue;
		    // if this is a constructor, than it may write only
		    // to fields of 'this'
		    if (isConstructor(hm) &&
			mpo.isMustParam(qq.objectref()) &&
			mpo.whichMustParam(qq.objectref())==0)
			continue; // this is a permitted write.
		    // writes by subclass methods to superclass fields are
		    // okay. (but not writes by 'this' methods to 'this'
		    // fields, unless the method is a constructor)
		    if (qq.field().getDeclaringClass()
			.isInstanceOf(thisClass) &&
			(isConstructor(hm) ||
			 !thisClass.equals(qq.field().getDeclaringClass())))
			continue; // subclass writes are permitted.
		    // non-permitted write!
		    badFields.add(qq.field());
		}
	    }
	    // on to the next!
	}
	// done!  we have set of all bad (not subclass-final) fields.
	return Collections.unmodifiableSet(badFields);
    }
		

    ///////// copied from harpoon.Analysis.Quads.DefiniteInitOracle.
    /** return a conservative approximation to whether this is a constructor
     *  or not.  it's always safe to return true. */
    boolean isConstructor(HMethod hm) {
	// this is tricky, because we want split constructors to count, too,
	// even though renamed constructors (such as generated by initcheck,
	// for instance) won't always be instanceof HConstructor.  Look
	// for names starting with '<init>', as well.
	if (hm instanceof HConstructor) return true;
	if (hm.getName().startsWith("<init>")) return true;
	// XXX: what about methods generated by RuntimeMethod Cloner?
	// we could try methods ending with <init>, but then the
	// declaringclass information would be wrong.
	//if (hm.getName().endsWidth("<init>")) return true;//not safe yet.
	return false;
    }
}
