// MZFWidenType.java, created Tue Nov 13 00:23:59 2001 by cananian
// Copyright (C) 2000 C. Scott Ananian <cananian@alumni.princeton.edu>
// Licensed under the terms of the GNU GPL; see COPYING for details.
package harpoon.Analysis.SizeOpt;

import harpoon.Analysis.Transformation.MethodMutator;
import harpoon.ClassFile.HClass;
import harpoon.ClassFile.HCode;
import harpoon.ClassFile.HCodeAndMaps;
import harpoon.ClassFile.HCodeFactory;
import harpoon.ClassFile.HField;
import harpoon.ClassFile.Linker;
import harpoon.IR.Quads.ANEW;
import harpoon.IR.Quads.INSTANCEOF;
import harpoon.IR.Quads.Quad;
import harpoon.IR.Quads.QuadVisitor;
import harpoon.IR.Quads.TYPESWITCH;
import harpoon.Util.HClassUtil;
import harpoon.Util.Util;

import java.util.List;
import java.util.Map;
/**
 * <code>MZFWidenType</code> widens the types mentioned in
 * <code>ANEW</code>, <code>INSTANCEOF</code>, and <code>TYPESWITCH</code>
 * quads so that they play nicely with the split types generated by
 * <code>MZFCompressor</code>.
 * 
 * @author  C. Scott Ananian <cananian@alumni.princeton.edu>
 * @version $Id: MZFWidenType.java,v 1.1.2.1 2001-11-13 21:34:10 cananian Exp $
 */
class MZFWidenType extends MethodMutator {
    /** the linker to use */
    final Linker linker;
    /** a map from HClasses to a list of sorted fields; the splitting has
     *  been done in the order of the list. */
    final Map listmap;
    /** a map from <code>HField</code>s to the <code>HClass</code> which
     *  eliminates that field. */
    final Map field2class;
    /** Creates a <code>MZFWidenType</code>. */
    public MZFWidenType(HCodeFactory hcf,
			Linker linker, Map listmap, Map field2class) {
        super(hcf);
	this.linker = linker;
	this.listmap = listmap;
	this.field2class = field2class;
    }
    protected HCode mutateHCode(HCodeAndMaps input) {
	HCode hc = input.hcode();
	QuadVisitor qv = new QuadVisitor() {
		public void visit(Quad q) { /* booring. */ }
		public void visit(ANEW q) {
		    Quad.replace
			(q, new ANEW(q.getFactory(), q, q.dst(),
				     widen(q.hclass()), q.dims()));
		}
		public void visit(INSTANCEOF q) {
		    Quad.replace
			(q, new INSTANCEOF(q.getFactory(), q, q.dst(),
					   q.src(), widen(q.hclass())));
		}
		public void visit(TYPESWITCH q) {
		    HClass[] keys = (HClass[]) q.keys().clone();
		    for (int i=0; i<keys.length; i++)
			keys[i] = widen(keys[i]);
		    Quad.replace
			(q, new TYPESWITCH(q.getFactory(), q, q.index(),
					   keys, q.dst(), q.src(),
					   q.hasDefault()));
		}
	    };
	Quad[] qa = (Quad[]) hc.getElements();
	for (int i=0; i<qa.length; i++)
	    qa[i].accept(qv);
	// done.
	return hc;
    }
    HClass widen(HClass hc) {
	if (hc.isPrimitive() || hc.isInterface())
	    return hc;
	if (hc.isArray())
	    return HClassUtil.arrayClass
		(linker, widen(HClassUtil.baseClass(hc)), HClassUtil.dims(hc));
	List sortedFields = (List) listmap.get(hc);
	if (sortedFields==null) return hc; // not a split class.
	List lastpair = (List) sortedFields.get(sortedFields.size()-1);
	HField lastF = (HField) lastpair.get(0);
	HClass broadest = (HClass) field2class.get(lastF);
	Util.assert(broadest!=null);
	return broadest;
    }
}
