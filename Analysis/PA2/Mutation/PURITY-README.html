<html>


<head>
<title>
Purity Analysis Kit
</title>
</head>


<body>

<h1>Purity Analysis Kit v0.03</h1>


<b>
Copyright (c) 2005 - <a href="http://www.mit.edu/~salcianu">Alexandru
Salcianu</a> &lt;salcianu@alum.mit.edu&gt;<br>
GNU General Public Licence
</b>


<p>
<b>Table of Contents:</b>

<ul>
 <li><a href="#licence-info">A. Licence Information</a>
 <li><a href="#purity-def">B. Definition of <i>Purity</i></a>
 <li><a href="#files">C. Download and Installation</a>
 <li><a href="#requirements">D. Requirements</a>
 <li><a href="#testing">E. Testing everything works fine</a>
 <li><a href="#usage">F. Usage</a>
 <li><a href="#programmatic-access">G. Programmatic Access to the
 Analysis Results</a>
 <li><a href="#thorny-issues">H. Limitations / Thorny Issues</a>
 <li><a href="#getting-the-sources">I. Getting the Source Code</a>
</ul>


<b>Warning:</b> The purity analysis tool and this webpage are provided
as-they-are, without any guarantee or legal responsibility on behalf of
their authors.<br>

<p>
<b>Note:</b> This HTML file serves a double purpose: (1) the main
webpage for the purity analysis kit, and (2) the
<code>README.html</code> file included in he kit.  When you read this
file as part of the kit, some of the relative URLs may be invalid;
however, this should not affect you, since by that time you should
already have all the required files.


<a name="licence-info"><h2>A. Licence information</h2></a>

This purity analysis tool is released under the terms of the GNU
General Public Licence (GNU GPL), available online from <a
href="COPYING">here</a>.  Please discontinue using this tool if you
disagree with the GNU GPL.  See <a href="#getting-the-sources">Section
I</a> below to find out how you can obtain the source code.


<a name="purity-def"><h2>B. Definition of <i>Purity</i></h2></a>

This tool implements the combined pointer and purity analysis
described in our <a
href="http://www.mit.edu/~salcianu/publications.html#vmcai05-purity">VMCAI'05
paper</a>.  Our analysis considers a method pure if it does not mutate
any object that existed before the method was invoked; this is also
the definition used in <a
href="http://www.cs.iastate.edu/~leavens/JML">JML</a>.  Notice that a
method that is pure according to this definition may still create,
mutate and even return new objects.  The reason JML uses this
definition is that if a method does not mutate any pre-existent
object, the invariants attached to those objects propagate over calls
to that method.  In addition, as a special case, our (and JML's)
definition of purity allows a pure constructor to mutate fields of the
<code>this</code> object. <i>[ However, as explained in the Section
F. below, you may use the option
<code>--no-jml-constructor-purity</code> to instruct the analysis to
consider such constructors impure. ]</i>



<a name="files"><h2>C. Download and Installation</h2></a>

The purity analysis kit consists of a <code>.tgz</code> archive file
that you can download from <a href="purity-kit.tgz">here</a>.  It
decompresses into a directory named <code>purity-kit</code>, containg
the following files/subdirs:


<ol>

<li> <code>purity.jar</code> - Contains the classes of the purity
   analysis, together with the rest of the <a
   href="http://flex-master.csail.mit.edu/Harpoon">Flex</a> compiler
   infrastructure.  The Java source code files are available from the
   <a href="http://flex-master.csail.mit.edu/Harpoon">Flex
   website</a>.  Flex is an open-source compiler infrastructure built
   in Prof. Rinard's group at MIT.

<p>
<li> <code>suppJars/</code> - Subdirectory with the two <code>.jar</code>
   libraries used by the implementation of the purity analysis:
   <code>jpaul.jar</code> and <code>jutil.jar</code>.  These files are
   not really part of the purity analysis: they are provided here only
   for your convenience.  You may also find them, together with their
   sources and Javadoc documentation, on the websites of the <a
   href="http://jpaul.sourceforge.net">jpaul</a> and the <a
   href="http://cscott.net/Projects/JUtil/jutil-latest/doc">JUtil</a>
   projects.

<p>
<li> <code>lib/</code> - Subdirectory that contains the implementation
   of the Java standard library that Flex compiles/analyzes Java
   applications against.

   <p>
   Clarification: the analyzed application consists of (1) the user
   code, and (2) the standard library from <code>lib/</code> (more
   precisely, the current tool analyzes only those parts of (1) and
   (2) that are transitively callable from the main method).  Notice
   that the Java standard library from (2) may be different from the
   Java standard library used by your JVM.

   <p>
   Currently, we use the Java standard library as implemented by the
   <a href="http://www.gnu.org/software/classpath">GNU Classpath</a>
   project.  More specifically, <code>lib/</code> contains the
   <code>glibj.zip</code> from GNU Classpath v0.08, and two
   <code>.jar</code>s that reconcile GNU Classpath with the object
   layout used by our compiler.  Not sure they are really necessary
   for the purity analyses, but better safe than sorry :) For the
   purposes of purity analysis, you <b>do not</b> need to separately
   download/install GNU Classpath 0.08; however, if you decide to take
   a look at it, you may donwload it from the <a
   href="http://www.gnu.org/software/classpath">GNU Classpath</a>
   official website or directly from <a
   href="classpath-0.08.tar.gz">here</a>.

<p>
<li> <code>jolden/</code> - Subdirectory containing the Java Olden
   bechmarks.  These applications are not part of the purity analysis:
   they are provided here only as testcases.

<p>
<li> <a
   href="http://www.gnu.org/copyleft/gpl.html"><code>COPYING</code></a>
   - The GNU GPL Licence details.

<p>
<li> <code>purity-test</code> and <code>flex-self-test</code> - Two
testing scripts.

<p>
<li> <code>README.html</code> - The file you are reading right now.

</ol>


<a name="#requirements"><h2>D. Requirements</h2></a>

<b>Software:</b> JDK 1.5 (Java with generics).  The purity tool has
been tested on Linux (RedHat, Debian, Fedora Core 3) with the first 5
releases of SUN JDK 1.5.0 (_01 to _05).  You should make sure that the
<code>CLASSPATH</code> of your JVM contains the following files:
<code>purity.jar</code>, <code>suppJars/jutil.jar</code>, and
<code>suppJars/jpaul.jar</code>.

<p>
<b>Hardware:</b> a fast machine (recommended: P4 @ 3.2GHz or
equivalent) with a lot of memory (recommended: 1Ghz for medium
benchmarks, at least 2Ghz for more ambitious ones).



<a name="testing"><h2>E. Testing</h2></a>

Once you have all files in place, it's a good idea to test right
away whether you can successfully run the purity analysis.  To do
this, execute

<p>
<code>
  cd purity-kit<br>
  ./purity-test
</code>

<p>
The <code>purity-test</code> script should analyze two Java Olden
benchmarks from <code>jolden/</code>.  If everything goes fine, the
script will generate a very verbose output, full of progress
indicators; at the end of the analysis of each application, the
analysis will print a short statistic regarding the total number of
pure methods.  If you want to analyze all of the ten Java Olden
benchmarks, execute

<p>
<code>
  ./purity-test all
</code>

<p>
<code>purity-test</code> creates a <code>results/</code>
subdirectory containing files with the analysis trace for each
analyzed testcase.

<p>
If you want to do a really big test, then run

<p>
<code>
  ./flex-self-test
</code>

<p>
The <code>flex-self-test</code> script performs the purity analysis on
the entire code reachable from the Flex top-level class
harpoon.Main.SAMain (this includes the code of the analysis and much
more).  This should analyze 14,000+ methods of almost 450,000 bytecode
instructions, in almost an hour on a P4 @ 3.2Ghz with 2Gb RAM (30
minutes for the pointer and purity analysis itself).



<a name="usage"><h2>F. Usage</h2></a>

<b>Reminder:</b> Before using the purity analysis, you should make
sure that <code>purity.jar</code>, <code>suppJars/jpaul.jar</code> and
<code>suppJars/jutil.jar</code> are on your JVM's <code>CLASSPATH</code>.

<p>
The entry point for the purity analysis is the method 

<p>
<code>
  public static void harpoon.Main.Purity.main(String[] args)
</code>

<p>You may invoke this method in two ways: (1) programmatically (e.g.,
from another Java class); or (2) by starting your favorite JVM with
the class <code>harpoon.Main.Purity</code> as main class.

<p>The elements of the <code>args</code> array parameter correspond to
the command line arguments.  They should be, in order:

<ol>

<li><code>args[0]</code> - The name of the main class of the
application you want to analyze.

<p>
<li><code>args[1]</code> - The path where your application resides.
As any Java CLASSPATH, this path can contain several elements
(directors, <code>.jar</code> files, and <code>.zip</code> files),
separated by ":".  The path that the analysis uses in order to load
analyzed classes consists of (in order):

<table border=1>

<tr valign=top>
<td>1</td>
<td colspan="2">The user-defined path (i.e., the value of <code>args[1]</code>).</td>
</tr>

<tr valign=top>
<td>2</td>
<td><code>lib/reflect-thunk.jar:<br>lib/cpvm.jar</code></td>
<td>
Reimplement a few classes (e.g., reflection related ones), in order to
"reconcile" GNU Classpath 0.08 with the object layout of our compiler.
</td>
</tr>

<tr valign=top>
<td>3</td>
<td><code>lib/glibj-0.08-extra.jar</code></td>
<td>
A few additions to GNU Classpath 0.08; required to analyze class files
generated with JDK 1.5.0.  GNU Classpath 0.08 implements the Java
library up to 1.1, plus some parts of 1.2, but does not contain
classes like <code>java.lang.StringBuilder</code> (introduced in JDK
1.5).  Needless to say, this <code>.jar</code> does not fully upgrade
GNU Classpath 0.08 to JDK 1.5; we provided only the files that are
required such that the analysis can analyze itself.
</td>
</tr>

<tr valign=top>
<td>4</td>
<td><code>lib/glibj-0.08.zip</code></td>
<td>
The classes from the GNU Classpath 0.08 Java standard library.
</td>
</tr>

</table>


<p>
<li>The rest of the arguments are passed verbatim to
<code>harpoon.Main.SAMain.main(String[] args)</code>.  Here are a few
possible options you may use:

<ul>

<li><code>--no-jml-constructor-purity</code>: the
analysis considers impure the constructors that mutate the fields of
the <code>this</code> object.

<li><code>--daikon-purity-file <i>&lt;fileName&gt;</i></code>: the
analysis will output a textfile with the names of the pure methods,
one method name per line (no empty lines).  [ Note: this option
requires two entries in the <code>args</code> array: one for the
string <code>&quot;--daikon-purity-file&quot;</code> and one for
the file name. ]

<p>
The method name format in the output file is
that produced by <code><a
href="http://flex-master.csail.mit.edu/Harpoon/doc/harpoon/ClassFile/HMethod.html">HMethod</a>.toString()</code>,
which is itself identical to the format produced by
<code>javap</code>: access qualifiers, space, fully qualified result
type, space, fully qualified class name, dot, method name, open paran,
comma-separated list of fully qualified parameter types, closed paran,
and (if the method throws any exceptions), space, the keyword
<code>throws</code>, space, comma-separated list of fully qualified
exception types.  Here is an example:

<p>
<code>
public java.lang.String java.io.File.getCanonicalPath() throws
java.io.IOException<br>
public int java.util.Collections$SynchronizedCollection.size()
</code>


<p>This file can be passed to the Daikon invariant detector.

</ul>

</ol>

<p>
<b>Warning:</b> you can take a look at the <code>./purity-test</code> and
<code>./flex-self-test</code>, but they are far more complex than what
you actually need.  The reason for this complexity is that I also use
them for testing while doing development in the Flex project, and the
locations of certains elements are different than in the kit.



<a name="programmatic-access"><h2>G. Programmatic Access to the Analysis Results</h2></a>

<p>
The purity analysis examines (almost) all methods that may be
transitively callable from the main method of the application (i.e.,
the <code>main</code> method of the main class).  After the analysis
terminates, all detected pure methods are put in a set stored in a
static field in the class
<code>harpoon.Analysis.PA2.Mutation.WPMutationAnalysisCompStage</code>:

<p>
<code>
  public static Set&lt;HMethod&gt; pureMethods;
</code>

<p>
<i>[ We say "almost" because, for efficiency reasons, the analysis skips
(i.e., considers unanalyzable) several large library methods, whose
analysis takes a long time and does not seem to produce anything
useful.  Those methods deal with the SecurityManager and the time
zones.  Let me know if you really care about them: the analysis can
analyze them, at the cost of a bigger analysis time. ]</i>

<p>
Also, the analysis stores a map from each analyzed method to a list of
the indices of the "safe" parameters.  A parameter is safe if, for any
object transitively reachable from that parameters, (1) the method
does not mutate it, and (2) the method does not create new
externally-visible aliasing to that object (this precludes storing
references to such an object into a static, or returning such an
object).  This map is stored in another static field of 
<code>harpoon.Analysis.PA2.Mutation.WPMutationAnalysisCompStage</code>:

<p>
<code>
  public static Map&lt;HMethod,List&lt;Integer&gt;&gt; method2SafeParam;
</code>

<p>
The parameter indices start from 0 and take into account all
parameters, including those of primitive types, and, in the case of
instance methods, the implicit this argument (the first one, i.e.,
#0).

<p>
<code>harpoon.ClassFile.HMethod</code> is the Flex handle for a method
from the analyzed code.  Full Javadoc available on the <a
href="http://flex-master.csail.mit.edu/Harpoon">Flex website</a>, or
directly through this <a
href="http://flex-master.csail.mit.edu/Harpoon/doc/harpoon/ClassFile/HMethod.html">URL</a>.



<a name="thorny-issues"><h2>H. Limitations / Thorny Issues</h2></a>


<ul>

<li><b>Scalability problems:</b>

The current implementation (the first version of which was completed
in September 2005) is much faster than the one used for the benchmarks
from the VMCAI'05 paper; in particular, the current implementation is
able to analyze itself in less than an hour (the pointer and purity
analysis taking 30 minutes, with the rest of the time spent on
intermediate representation construction, call-graph construction, and
other compiler stages).  Still, even the current implementation has
problems when analyzing big programs.  Most of these problems stem
from the fact that we use an inherently expensive pointer analysis;
some other problems are due to the fact that some parts of the Flex
compiler infrastructure are not very fast.

<p>
The primary goal of the research presented in the VMCAI'05 paper was
to support a more flexible notion of purity than previous analyses; in
particular, we want to allow pure methods to mutate newly allocated
objects (e.g., the objects allocated in order to construct the method
result).  There are other published purity analyses (although it is
unclear whether there is any publicly-available tool behind them);
some of these analyses support a stricter notion of purity and claim
to be faster that this analysis; if interested, please search these
papers using your favorite search engine and contact their authors
directly.  Alternatively, if you are an author of such an analysis,
have a publicly available implementation, and want it mentioned here,
please drop <a href="http://www.mit.edu/~salcianu">Alex Salcianu</a>
an email, and your project will be mentioned here.


<!--
a good such example is <a
href="http://www.cse.ohio-state.edu/~rountev/">Atanas Rountev</a>'s
analysis described in his ICSM'04 paper "Precise Identification of
Side-Effect-Free Methods in Java" (available, for a small cost, from
<a
href="http://doi.ieeecomputersociety.org/10.1109/ICSM.2004.1357793">here</a>).
-->


<p>
<li><b>Full program analysis:</b> 

The current implementation requires a full program, i.e., by default,
it cannot analyze a library.  Here is why: the analysis is
inter-procedural and requires a call-graph for the analyzed program.
The analysis needs to know all potential callees for a virtual call of
the form <code>o.foo()</code>; this requires knowledge of the types of
all objects that <code>o</code> may point to (once we know this, we
can find out what <code>foo</code> method is invoked for each such
class).  The current call-graph computation takes place before the
pointer analysis and is quite simple: it first determines all classes
that may be instantiated in the program; next, for each virtual call
of the form <code>o.foo()</code>, it considers all subclasses of the
declared type for <code>o</code> that are instantiated in the current
program.  <i>[ Theoretically, it is possible to design and implement a
combined call-graph and pointer analysis; however, the pointer
analysis alone is very complex so I never investigated such a
combination. ]</i>

<p>
So far we have explained the need to know all classes that may
possibly be instantiated in a program.  Discovering this information
requires knowledge of all methods that may be invoked by the analyzed
program (because each method can instantiates classes that may not be
instantiated anywhere else in the program).  Detecting all invoked
methods and all instantiated classes is complex in the presence of (1)
class instantiation via reflection, and (2) native methods - that our
compiler infrastructure (that deals only with Java bytecode) does not
see.  That's how we run into the other difficulty, finding the
appropriate set of <i>roots</i> (see next point).


<p>
<li><b>Finding the Appropriate Set of Program Roots:</b> In big lines,
a <i>root</i> is (1) a Java class/method that is instantiated/invoked
using reflection and dynamic class loading; (2) a Java class/method
that is instantiated/invoked by a native method.

<p>
In general, Flex (or any other static compiler) is unable to find the
roots of type (1) (e.g., the program can load classes with names read
from an input file).  Theoretically, the roots of type (2) should be
easy to find by the compiler, once we know the specific Java standard
library we compile against (we just make the compiler know about the
Java classes/methods that each native method from the standard library
instantiates/invokes).  Still, Flex does not always do this (please
don't ask me why; hopefully, this "feature" will be fixed at some
point); sometimes, it may be possible to use the additional command
line option <code>-r &lt;rootSetFileName&gt;</code> and pass a few
additional roots.

<p>
The root problem introduces a new limitation: Flex cannot compile /
analyze applications against arbitrary implementations of the Java
standard library (see next point).


<p>
<li><b>Specific Java Standard Library Only:</b> Currently, Flex
compiles / analyzes applications against the GNU Classath 0.08
implementation of the Java standard library.  The reasons should be
obvious from reading the previous points.  If your application uses a
part of the standard library that is not in the currently used Java
library, you're in trouble ...

<p>
<i>[ You may be confused that we don't base our tool on one of the Sun
JDK implementations of the standard library (a
<code>classes.zip</code> / <code>rt.jar</code> file from a Sun JDK).
The reason has to do with the copyright attached to the Sun JDK, and
we don't want to say more here. ]</i>


<p>
<li><b>Correctness Issues:</b>

Although the underlying theoretical analysis is correct, there are
several sources of unsoundness in the current implementation:

<ul>

<li><b>This is a research prototype, not an industrial tool!</b>
Please have realistic assumptions before using this tool; due to the
lack of resources (i.e., time) it has not been engineered to
perfection.  Bug reports to <a
href="http://www.mit.edu/~salcianu">Alex Salcianu</a> should consist
of a plain-text email with a URL to a place that contains: (1) the
file <code>purity-kit.tgz</code> that you're using (such that we make
sure we debug the same version of the tool); (2) the application you
analyze (including all relevant <code>.jar</code> / <code>.zip</code>
files); (3) a text file containing the error trace, i.e., the output
of the analysis; (4) the command line / script / Java code you use to
invoke the analysis.  Of course, there is no time guarantee about the
processing of the bug reports.

<p>
<li><b>Assumptions about <i>special methods</i></b>: Several methods appear
almost everywhere, and confuse the call-graph computation.  E.g., many
call-graph construction algorithms would normally report almost all
<code>toString</code> methods from the program (and many other
methods) as being part of a "nest" of mutually recursive methods.  The
reason is that these methods generally call
<code>StringBuffer.append(Object)</code>, which calls
<code>String.valueOf(Object)</code>; this last method returns
<code>"null"</code> if its argument is null; otherwise, it dynamically
dispatch the <code>toString()</code> method on its <code>Object</code>
argument, which (statically) appears to invoke all
<code>toString()</code> methods from the program! <i>[ You are right, one
could remove some of these problems by inlining
<code>String.valueOf</code> until the type of its argument becomes
more specific that <code>Object</code>; this will solve some, but not
all the problems. ]</i>

<p>
Other similar methods are <code>equals</code> and
<code>hashCode</code>.  Clearly, running an inter-procedural
fixed-point algorithm on groups of dozens, possibly hundreds of
methods will be too slow.  However, notice that we don't usually
expect these methods to perform mutation.  To speed up the analysis,
we assume that these methods are safe with respect to all their
parameters (the methods do not mutate and do not create new externally
visible paths to any object transitively reachable from the
parameters).  We assume this property about all overriders of the
following methods:

<p>
<code>
String java.lang.Object.toString();<br>
boolean java.lang.Object.equals(Object);<br>
int java.lang.Object.hashCode();<br>
int java.lang.Comparable.compareTo(Object);<br>
</code>

<p>
This assumption allows the analysis to treat calls to such methods
very fast, bypassing the usual inter-procedural algorithm.  Of course,
after the analysis terminates, you can look over its log and see if
any special method violated the assumption.  In general, this happens
because of some caching mechanism (i.e., the methods updates a cache
pointed from the <code>this</code> parameter); in that case, you can
check manually that the caching mechanism is just a speed issue, with
no impact on the semantics of the program.

</ul>

</ul>


<p>
Good luck!

<hr>

<b>
Copyright (c) 2005 - <a href="http://www.mit.edu/~salcianu">Alexandru
Salcianu</a> &lt;salcianu@alum.mit.edu&gt;<br>
GNU General Public Licence<br>
File CVS version: $Id: PURITY-README.html,v 1.7 2005-11-30 17:10:27 salcianu Exp $
</b>



<a name="getting-the-sources"><h2>I. Getting the Source Code</h2></a>

The entire source code for the purity kit is available as part of the
<a href="http://flex-master.csail.mit.edu/Harpoon">MIT Flex</a>
compiler infrastructure.  Ideally, we should have the compiler
infrastructure completely separated and next have the purity kit
simply use it.  However, right now the purity analysis is part of the
Flex source tree, together with many other things.  [ The main reason
for this situation is that I did a lot of bug-fixes and changes in
Flex itself so the separation was not that clear; another reason is my
laziness and convenience. ]

<p>
To get the code, go to the <a
href="http://flex-master.csail.mit.edu/Harpoon">Flex website</a> and
see the instructions on getting the CVS snapshot (the <i>stable</i>
releases are very old and irrelevant for the purity-kit; hopefully,
one day we'll make an updated stable release).  The script
<code>$FLEX/Analysis/PA2/Mutation/purity-kit</code> packages the
purity analysis (and the rest of Flex) into the purity-kit.

<p>
<strong>Warning:</strong> Flex is a <strong>research
prototype</strong> (both words are very important!); it is not a
production-strength tool.  Understanding, changing, recompiling, and
using Flex is very difficult, so please do not venture into it unless
you are highly-motivated and have plenty of time.  You have been
warned :)


</body>
</html>
