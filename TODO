---- Sep-11-98, cont
Add SWITCH nodes to CJMP, SWITCH:
 call them lamba-functions.  <t1, t2, ...> = lambda(t0)
 return a tuple, given a temp (and a predicate?)
 reverse of phi functions.  translated the same way.
 There should be a lamba-function for variable a at node z of the flowgraph
 example when:
  1) block x contains a *use* of a
  2) block y contains a *use* of a
  3) there is a non-empty path Pxz of edges from z to x,
  4) there is a non-empty path Pyz of edges from z to y, and
  5) paths Pxz and Pyz do not have any node in common except z (that is,
     z is the first point of convergence of these paths).
QUESTION: are criteria 1 and 2 correct.  Maybe where 1 *or* 2 is true?
QUESTION: how do you make a predicated analysis based on this?
QUESTION: how does phi-function placement interact with lamba-function 
          placement?
write analysis to remove unnecessary control dependencies.  PARALLEL quad?

Write registration routines for HMethod.
Make superclass 'Register' or 'Initialize' or 'Harpoon' or something
 that registers all necessary representations (extend to do-it-yourself).
 Standard interface for registration object.  Static method in HCode
 to return instance of registration object.
---- Sep-11-98
Optimize INSTANCEOF and COMPONENTOF in SCC.
Update xLass to hold 'canbeNull' boolean.
Update OPER(acmpeq) to check canbeNull boolean.
Write optimization pass based on SCC analysis.
Rewrite SCC to use *edges* instead of *blocks* for executable analysis.
  ql is then set of all edge *targets*.  Doesn't have to be unique, but
  it'd be nice.
Rewrite SCC to use Visitor pattern.
Rewrite SCC to use *sets* of classes?
---- Sep-10-98
O Change PHI implementation to not make phi function entries for
  local variables that have not yet been defined.  Change State initialization
  to put 'null' in undefined local variables.
Write CleanUp class in IR.QuadSSA to:
  1) Remove phi functions that define a temp that is never used.
     (this will magically remove undefined temps as well).
  2) Shrink PHI functions that have phantom limbs (from impossible catches).
---- Sep-09-98
Undo MONITOR block transform.  Make it a poor statement.
Change DCMPL/DCMPG/FCMPL/FCMPG bytecode operations to
conform to the integer standard: _CMPEQ, _CMPGE, _CMPGT.
---- Sep-04-98
X Add FOOTER block to allow reverse traversals.
X Fix RET handling -- RET should return to source of JSR.
Fix the way the 'any exception' try is handled 
X Check assumption that 'any' == Throwable in exception handler description.
Make list of exception handling statements in translate phase so we can
 strip them all out when regenerating java.  obviously try/catch block-related
 statements must stay.
X Make monitor blocks work.
X Enclose synchronized methods in monitor blocks.
Runtime exception check on MONITOREXIT.
---- Aug-25-98
Figure out if we really need JMP/NOP/LET quads.

---- Aug-24-98
Test:
 method() {
   synchronized(new Object()) {
     synchronized(new Object()) {
     }
   }
 }
Test:
 method() {
  try {
   try {
    ;
   } catch (x) {
   }
  } catch (y) {
  }
 }

---- Aug-21-98
X Implement INSTANCEOF in the IR (special method? special Quad? subclass OPER?)
X Implement CHECKCAST
O Make Temps into Leafs in Quad rep.
  [made Leafs into Temps...]

---- Aug-7-98
O Figure out how classes will be laid out in the JavaChip.
X Figure out what we're doing about arrays.

---- Aug-5-98
X Fix munge/unmunge to be pipeline-safe

---- Aug-3-98
X Finish InCti class.

---- Aug-2-98
X Interface should have:
X   convert method, to go from one form to another.
X    (automagic chaining, if each form just knows one other source form&convers.)
X  line number method.
X  enumeration method.
X  name method (of course) -- (change putCode)

X Add new interface type for primitive types (simplify isPrimitive)
O   only one method in interface: getDescriptor();
O each type has value/add/sub/etc methods that are *not in interface*
O   because return value is of the same primitive type (ie, not object)
O   see java.lang.reflect rules for encapsulating return values.
O   want to be able to specify that type is Z, not java.lang.Boolean obj.
O   think this one over.
O Easy.  Superclass basic java language type objects with our special
O  'primary type' object.  Then we can easily tell which is which.
O  (we can also add cool add/sub/etc functions while we're at it.)

---- Aug-1-98
X Make --CUTHERE-- file joiner/separator (perl?)
X use above to search/replace <cananian...> with (cananian...)
X write "getCode(String format)" method to HMethod, preload with byte[].
X  -- find out whether interface methods have code attributes.
X     NOPE!
X write "print( )" methods to pretty-print a class file.
X  -- separate ones for raw and HClass?
X     -- HClass should pretty-print in java source form.
X     -- Raw.* should pretty-print the exact class file contents.
Xfigure out whether we are reporting methods of interfaces properly
X  (can we have an abstract interface method that doesn't show up in
X   the declaredMethods?)
X   WE ARE.  YOU CAN'T.
X add Java1.1 attributes (Synthetic and InnerClasses)
X add accessor function for SourceFile attribute
X add accessor function for localvariable attribute.
X create an interface type for all code representations.
X modify getCode to use it.
