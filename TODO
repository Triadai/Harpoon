---- Sep-19-98
Remove Tnull, Tzero code from top of function.  It's increasing the
 phi/sigma count by a lot (some multiple of n, where n is the number of
 splits/joins).
---- Sep-18-98
X Fix MONITOR handling.
---- Sep-16-98
[cananian@lesser-magoo Code]$ time java -mx128m harpoon.Main.Main harpoon.IR.QuadSSA.Translate
java.lang.OutOfMemoryError: 
        at java.util.Hashtable.<init>(Hashtable.java)
        at java.util.Hashtable.<init>(Hashtable.java)
        at harpoon.Util.Set.<init>(Set.java:17)
        at harpoon.IR.QuadSSA.CleanUp$UsedTable.addDef(CleanUp.java:61)
        at harpoon.IR.QuadSSA.CleanUp.cleanupUnused(CleanUp.java:88)
        at harpoon.IR.QuadSSA.CleanUp.cleanup2(CleanUp.java:35)
        at harpoon.IR.QuadSSA.Code.<init>(Code.java:40)
        at harpoon.IR.QuadSSA.Code$1.convert(Code.java:57)
        at harpoon.ClassFile.HMethod.getCode(HMethod.java:83)
        at harpoon.Main.Main.main(Main.java:30)
354.490u 2.850s 9:55.96 59.9%   0+0k 0+0io 20466pf+5635w
---- Sep-15-98
X Phi-placement analysis works, it just needs 'dead-code elimination'.
X  Remove any phi function that defines a variable that is never used.
---- Sep-14-98
Make sure Test/zeroopt.java is properly optimized.
X SWITCH processing is still broken.
Check try/catch processing.  I don't think we're putting in the right
  PHI functions.
X Maybe split phi/switch stuff into separate entities:
X  QUESTION: what do we do about optimizing ( x+1 < y )
---- Sep-14-98
Peephole optimizations on QuadSSA to normalize:
 1) instanceof -> icmp -> cjmp (or in general, boolean->icmp->cjmp)
    all boolean functions should feed a cjmp directly.
 2) lcmp,dcmp mess.  Look for CJMP whose test is def'd in a PHI statement,
    and remove the PHI, duplicating the CJMP.  May need to be a PHI->CJMP
    sequence. (make sure cmpgt->cmpeq is properly translated to cmpge, too.)
---- Sep-13-98
Write tool to print 'ConstantClass'es from bytecode files, and delete
 .classes that depend on out-of-date classes. Then some other tool can
 regenerate the missing classes.
Hierarchy goes:
 Top
 xClassNull extends Top -- classes; value could be 'null'
 xClass extends xClassNull -- a class; can *not* be null.
 xClassArray extends xClass -- an array class with a constant length (not null)
 BitSize extends xClass -- a value of the specified bit-width.
                           <lowest set bit, highest set bit>
 Bounds extends BitSize -- a bounded value lowval <= v <= highval
 Constant               -- a particular constant value.
For fast analysis, can not raise Bounds to another instance of Bounds.
Bounds must be raised to BitSize if bounds proved invalid.
---- Sep-12-98, cont
Massive SCC-based analysis can keep: array size, canbeNull, class sets, etc.
X Move harpoon.ClassFile.Bytecode to harpoon.IR.Bytecode
O Rename all *.Code classes to QuadCode, BytecodeCode, etc.
X Make UseDef into map/general class
X Remove SymTable package.
---- Sep-12-98
X Add 'assert' statements to HClass.forName and HClass.forDescriptor to protect
X  against '/' and '.' mistakes.
---- Sep-11-98, cont 2
O Move TypeMap, ConstMap to harpoon.Analysis
X -- moved to harpoon.Analysis.Maps
X Make ExecMap with two methods: isExec(Edge e) and isExec(Quad q).
X   this can be made to work whether the internal rep is Quads or Edges.
Make Optimization class that works given a ConstMap and an ExecMap.
X [make dummy execmap and constmap classes that return 'not a const' and
X  'is executable' for everything.]
---- Sep-11-98, cont
X Add SWITCH nodes to CJMP, SWITCH:
X  call them sigma-functions.  <t1, t2, ...> = sigma(t0)
X  return a tuple, given a temp (and a predicate?)
X  reverse of phi functions.  translated the same way.
X  There should be a sigma-function for variable a at node z of the flowgraph
X  example when:
X   1) block x contains a *use* of a
X   2) block y contains a *use* of a
X   3) there is a non-empty path Pxz of edges from z to x,
X   4) there is a non-empty path Pyz of edges from z to y, and
X   5) paths Pxz and Pyz do not have any node in common except z (that is,
X      z is the first point of convergence of these paths).
X QUESTION: are criteria 1 and 2 correct.  Maybe where 1 *or* 2 is true?
X QUESTION: how do you make a predicated analysis based on this?
QUESTION: how does phi-function placement interact with sigma-function 
          placement?
write analysis to remove unnecessary control dependencies.  PARALLEL quad?

X Write registration routines for HMethod.
X Make superclass 'Register' or 'Initialize' or 'Harpoon' or something
X  that registers all necessary representations (extend to do-it-yourself).
X  Standard interface for registration object.  Static method in HCode
X  to return instance of registration object.
---- Sep-11-98
Optimize INSTANCEOF and COMPONENTOF in SCC.
X Update xClass to hold 'canbeNull' boolean.
Update OPER(acmpeq) to check canbeNull boolean.
Write optimization pass based on SCC analysis.
X Rewrite SCC to use *edges* instead of *blocks* for executable analysis.
X   ql is then set of all edge *targets*.  Doesn't have to be unique, but
X   it'd be nice.
X Rewrite SCC to use Visitor pattern.
O Rewrite SCC to use *sets* of classes?
---- Sep-10-98
O Change PHI implementation to not make phi function entries for
O  local variables that have not yet been defined.  Change State initialization
O  to put 'null' in undefined local variables.
X Write CleanUp class in IR.QuadSSA to:
X   1) Remove phi functions that define a temp that is never used.
X      (this will magically remove undefined temps as well).
X   2) Shrink PHI functions that have phantom limbs (from impossible catches).
---- Sep-09-98
X Undo MONITOR block transform.  Make it a poor statement.
X Change DCMPL/DCMPG/FCMPL/FCMPG bytecode operations to
X conform to the integer standard: _CMPEQ, _CMPGE, _CMPGT.
---- Sep-04-98
X Add FOOTER block to allow reverse traversals.
X Fix RET handling -- RET should return to source of JSR.
X Fix the way the 'any exception' try is handled 
X Check assumption that 'any' == Throwable in exception handler description.
Make list of exception handling statements in translate phase so we can
 strip them all out when regenerating java.  obviously try/catch block-related
 statements must stay.
X Make monitor blocks work.
X Enclose synchronized methods in monitor blocks.
X Runtime exception check on MONITOREXIT.
---- Aug-25-98
X Figure out if we really need JMP/NOP/LET quads.

---- Aug-24-98
X Test:
X  method() {
X    synchronized(new Object()) {
X      synchronized(new Object()) {
X      }
X    }
X  }
Test:
 method() {
  try {
   try {
    ;
   } catch (x) {
   }
  } catch (y) {
  }
 }

---- Aug-21-98
X Implement INSTANCEOF in the IR (special method? special Quad? subclass OPER?)
X Implement CHECKCAST
O Make Temps into Leafs in Quad rep.
  [made Leafs into Temps...]

---- Aug-7-98
O Figure out how classes will be laid out in the JavaChip.
X Figure out what we're doing about arrays.

---- Aug-5-98
X Fix munge/unmunge to be pipeline-safe

---- Aug-3-98
X Finish InCti class.

---- Aug-2-98
X Interface should have:
X   convert method, to go from one form to another.
X    (automagic chaining, if each form just knows one other source form&convers.)
X  line number method.
X  enumeration method.
X  name method (of course) -- (change putCode)

X Add new interface type for primitive types (simplify isPrimitive)
O   only one method in interface: getDescriptor();
O each type has value/add/sub/etc methods that are *not in interface*
O   because return value is of the same primitive type (ie, not object)
O   see java.lang.reflect rules for encapsulating return values.
O   want to be able to specify that type is Z, not java.lang.Boolean obj.
O   think this one over.
O Easy.  Superclass basic java language type objects with our special
O  'primary type' object.  Then we can easily tell which is which.
O  (we can also add cool add/sub/etc functions while we're at it.)

---- Aug-1-98
X Make --CUTHERE-- file joiner/separator (perl?)
X use above to search/replace <cananian...> with (cananian...)
X write "getCode(String format)" method to HMethod, preload with byte[].
X  -- find out whether interface methods have code attributes.
X     NOPE!
X write "print( )" methods to pretty-print a class file.
X  -- separate ones for raw and HClass?
X     -- HClass should pretty-print in java source form.
X     -- Raw.* should pretty-print the exact class file contents.
Xfigure out whether we are reporting methods of interfaces properly
X  (can we have an abstract interface method that doesn't show up in
X   the declaredMethods?)
X   WE ARE.  YOU CAN'T.
X add Java1.1 attributes (Synthetic and InnerClasses)
X add accessor function for SourceFile attribute
X add accessor function for localvariable attribute.
X create an interface type for all code representations.
X modify getCode to use it.
