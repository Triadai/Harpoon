\chapter{Model-checking the software implementation}\label{sec:verification}
My work on both software and hardware transaction systems has
reiterated the difficulty of creating correct implementations of
concurrent and fault-tolerant constructs.  Automatic model checking is
a prerequisite to achieving confidence in the design and implementation.
Versions of the software transaction system have been modelled in
Promela using \Spin 4.1.0 and verified on an SGI 64-processor MIPS
machine with 16G of main memory.

Sequences of transactional and non-transactional load and store
operations were checked using two concurrent processes, and all possible
interleavings were found to produce results consistent with
the semantic atomicity of the transactions.  
Several test scripts were run against the
model using separate processors of the verification machine (\Spin
cannot otherwise exploit SMP).  Some representative costs include:
\begin{itemize}
\item testing two concurrent {\tt writeT} operations (including
  ``false flag'' conditions) against a single object required $3.8\times
  10^6$ states and $170$M memory;
\item testing sequences of transactional and non-transactional reads
  and writes against two objects (checking that all views of the two
  objects were consistent) required $4.6\times 10^6$ states and $207$M
  memory; and
\item testing a pair of concurrent increments at values bracketing the
  \FLAG value to 99.8\% coverage of the state space required
  $7.6\times 10^7$ states and $4.3$G memory.  Simultaneously
  model-checking a range of values caused the state space explosion
  in this case.
\end{itemize}
\Spin's unreachable code reporting was used to ensure that our test
cases exercised every code path, although this doesn't guarantee that
every interesting interaction is checked.

In the process one bug in \Spin was discovered\footnote{Breadth-first
search of atomic regions was performed incorrectly in \Spin 4.0.7;
this was fixed in \Spin 4.1.0.}
and a number of subtle race conditions in the model were discovered and
corrected.  These included a number of modelling artifacts: in
particular, we were extremely aggressive about reference-counting and
deallocating objects in order to control the size of the state space,
and this proved difficult to do correctly.  We also discovered some
subtle-but-legitimate race conditions in the transactions algorithm.
For example:
\begin{itemize}
\item A race allowed conflicting readers to be created while a writer
  was inside {\tt ensureWriter} creating a new version object.
\item Allowing already-committed version objects to be mutated when {\tt
    writeT} or {\tt writeNT} was asked to store a ``false flag'' produced
  races between {\tt ensureWriter} and {\tt
    copyBackField}.  The code that was expected to manage these races
  had unexpected corner cases.
\item Using a bitmask to provide per-field granularity
  to the list of readers proved unmanageable as there were three-way
  races between the bitmask, the readers list, and the version tree.
\end{itemize}
In addition, the model-in-progress proved a valuable design tool, as
portions of the algorithm could readily be mechanically checked to
validate (or discredit) the designer's reasoning about the concurrent
system.  Humans do not excel at exhaustive state space exploration.

\Spin is not particularly suited to checking models with dynamic
allocation and deallocation.  In particular, it considers the
location of objects part of the state space, and allocating object
A before object B produces a different state than if object B
were allocated first.  This artificially enlarges the
state space.  A great deal of effort was expended tweaking the
model to approach a canonical allocation ordering.  A better solution
to this problem would allow larger model instances to be checked.


\section{Promela primer}\label{sec:promela}\index{Promela}
A concise Promela reference is available at
\url{http://spinroot.com/spin/Man/Quick.html}; we will here attempt to
summarize just enough of the language to allow the model we've
presented in this thesis to be understood.

Promela syntax is C-like, with the same lexical and commenting
conventions.  Statements are separated by either a semi-colon, or,
equivalently, an arrow.  The arrow is typically used to separate a
guard expression from the statements it is guarding.

The program counter moves past a statement only if the statement is
{\it enabled}.  Most
statements, including assignments, are always enabled.
A statement consisting only of an expression is enabled iff the
expression is true (non-zero).
Our model uses three basic Promela statements: selection, repetition,
and {\tt atomic}.

The selection statement,
\begin{inlinecode}
if
:: guard -> statements
...
:: guard -> statements
fi
\end{inlinecode}
selects one among its options and executes it.  An option can be
selected iff its first statement (the guard) is enabled.  The
special guard {\tt else} is enabled iff all other guards are not.

The repetition statement,
\begin{inlinecode}
do
:: statements
...
:: statements
fi
\end{inlinecode}
is similar: one among its enabled statements is selected and executed,
and then the process is repeated (with a different statement possibly
being selected each time) until control is explicitly transfered out
of the loop with a {\tt break} or {\tt goto}.

Finally,
\begin{inlinecode}
atomic { statements }
\end{inlinecode}
executes the given statements in one indivisible step.  For the
purposes of this model, a {\tt d\_step} block is functionally identical.
Outside {\tt atomic} or {\tt d\_step} blocks, Promela allows
interleaving before and after every statement, but statements are
indivisible.

Functions as specified in this model are similar to C macros: every
parameter is potentially both an input {\it and} an output.  Calls to
functions with names starting with {\tt move} are simple assignments;
they've been turned into macros so that reference counting
can be performed.

\section{\Spin model for software transaction system}
The complete \Spin 4.1.0 model for the FLEX software transaction system is
presented here.  It may also be downloaded from
\url{http://flex-master.csail.mit.edu/Harpoon/swx.pml}.

{\footnotesize\verbatiminput{phd-swx.pml}}
